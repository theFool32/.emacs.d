#+PROPERTY: header-args:emacs-lisp :results silent :tangle "~/.emacs.d/init.el"
#+STARTUP: overview

* Early Initialization
#+begin_src emacs-lisp :tangle "~/.emacs.d/early-init.el"
;;; early-init.el --- -*- lexical-binding: t -*-

(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5
      package-enable-at-startup nil
      file-name-handler-alist nil
      site-run-file nil
      default-frame-alist
      '((vertical-scroll-bars . nil)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)

        (undecorated . t);会导致所有边框全部消失无法拖动调整窗口大小 需要加上后面两句
        (drag-internal-border . 1)
        (internal-border-width . 5)
        ;; (ns-transparent-titlebar . t)
        )

      mode-line-format nil
      byte-compile-warnings nil
      native-comp-async-report-warnings-errors nil
      warning-suppress-log-types '((comp) (bytecomp))
      display-time-default-load-average nil

      inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil
      inhibit-compacting-font-caches t

      frame-inhibit-implied-resize t
      frame-resize-pixelwise t

      load-prefer-newer nil
      auto-mode-case-fold nil

      bidi-display-reordering 'left-to-right
      bidi-paragraph-direction 'left-to-right
      cursor-in-non-selected-windows nil
      highlight-nonselected-windows nil

      fast-but-imprecise-scrolling t
      ffap-machine-p-known 'reject
      redisplay-skip-fontification-on-input t

      idle-update-delay 1.0
      )

(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(custom-set-variables '(x-select-enable-clipboard t))

;; Automatically reread from disk if the underlying file changes
(setq auto-revert-interval 3
      auto-revert-check-vc-info t)
(global-auto-revert-mode)

(savehist-mode)

(setq use-package-always-defer t
      use-package-enable-imenu-support t
      use-package-verbose (not (bound-and-true-p byte-compile-current-file))
      use-package-expand-minimally t
      use-package-compute-statistics nil)

(provide 'early-init)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; early-init.el ends here
#+end_src

* StartUp
#+begin_src emacs-lisp
;;; init.el --- -*- lexical-binding: t -*-
(defvar +my/start-time (current-time))

(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)
(add-hook 'emacs-startup-hook
          (lambda ()
            "Recover GC values after startup."
            (setq gc-cons-percentage 0.1)))

;; Load init-custom.el if it exists
(load (expand-file-name "init-custom.el" user-emacs-directory) nil 'nomessage)

(defvar +my/first-input-hook nil)
(defun +my/first-input-hook-fun ()
  (when +my/first-input-hook
    (run-hooks '+my/first-input-hook)
    (setq +my/first-input-hook nil))
  (remove-hook 'pre-command-hook '+my/first-input-hook-fun))
(add-hook 'pre-command-hook '+my/first-input-hook-fun)
#+end_src

* Const
#+begin_src emacs-lisp
;; Load env
(let ((my-env-file (concat user-emacs-directory "env")))
  (when (and (or (display-graphic-p)
                 (daemonp))
             (file-exists-p my-env-file))
    (if (not (file-readable-p my-env-file))
        (unless noerror
          (signal 'file-error (list "Couldn't read envvar file" my-env-file)))
      (let (envvars environment)
        (with-temp-buffer
          (save-excursion
            (insert "\n")
            (insert-file-contents my-env-file))
          (while (re-search-forward "\n *\\([^#= \n]*\\)=" nil t)
            (push (match-string 1) envvars)
            (push (buffer-substring
                   (match-beginning 1)
                   (1- (or (save-excursion
                             (when (re-search-forward "^\\([^= ]+\\)=" nil t)
                               (line-beginning-position)))
                           (point-max))))
                  environment)))
        (when environment
          (setq process-environment
                (append (nreverse environment) process-environment)
                exec-path
                (if (member "PATH" envvars)
                    (append (split-string (getenv "PATH") path-separator t)
                            (list exec-directory))
                  exec-path)
                shell-file-name
                (if (member "SHELL" envvars)
                    (or (getenv "SHELL") shell-file-name)
                  shell-file-name))
          envvars)))))

;; UserInfo
(setq user-full-name "theFool32")
(setq user-mail-address "saber.rl32@gmail.com")
;; -UserInfo

;; Consts
(defconst *sys/gui*
  (or (display-graphic-p) (daemonp))
  "Are we running on a GUI Emacs?")

(defconst *sys/win32*
  (eq system-type 'windows-nt)
  "Are we running on a WinTel system?")

(defconst *sys/linux*
  (eq system-type 'gnu/linux)
  "Are we running on a GNU/Linux system?")

(defconst *sys/mac*
  (eq system-type 'darwin)
  "Are we running on a Mac system?")

(defconst *rg*
  (executable-find "rg")
  "Do we have ripgrep?")

(defconst *git*
  (executable-find "git")
  "Do we have git?")
#+end_src

* Package Manager
** Use-package =after-call=
#+begin_src emacs-lisp
(defvar +use-package--deferred-pkgs '(t))
(defun use-package-handler/:after-call (name _keyword hooks rest state)
  "Add keyword `:after-call' to `use-package'.
The purpose of this keyword is to expand the lazy-loading
capabilities of `use-package'.  Consult `use-package-concat' and
`use-package-process-keywords' for documentations of NAME, HOOKS,
REST and STATE."
  (if (plist-get state :demand)
      (use-package-process-keywords name rest state)
    (let ((fn (make-symbol (format "grandview--after-call-%s-h" name))))
      (use-package-concat
       `((fset ',fn
               (lambda (&rest _)
                 (condition-case e
                     (let ((default-directory user-emacs-directory))
                       (require ',name))
                   ((debug error)
                    (message "Failed to load deferred package %s: %s" ',name e)))
                 (when-let (deferral-list (assq ',name +use-package--deferred-pkgs))
                   (dolist (hook (cdr deferral-list))
                     (advice-remove hook #',fn)
                     (remove-hook hook #',fn))
                   (setq +use-package--deferred-pkgs
                         (delq deferral-list +use-package--deferred-pkgs))
                   (unintern ',fn nil)))))
       (cl-loop for hook in hooks
                collect (if (string-match-p "-\\(?:functions\\|hook\\)$" (symbol-name hook))
                            `(add-hook ',hook #',fn)
                          `(advice-add #',hook :before #',fn)))
       `((unless (assq ',name +use-package--deferred-pkgs)
           (push '(,name) +use-package--deferred-pkgs))
         (nconc (assq ',name +use-package--deferred-pkgs)
                '(,@hooks)))
       (use-package-process-keywords name rest state)))))
;; (require 'use-package-core)
(require 'use-package)
(push :after-call use-package-deferring-keywords)
(setq use-package-keywords (use-package-list-insert :after-call use-package-keywords :after))
(defalias 'use-package-normalize/:after-call #'use-package-normalize-symlist)

#+end_src

** Straight
#+begin_src emacs-lisp
(setq straight--process-log nil
      straight-vc-git-default-clone-depth 1
      straight-use-package-by-default t
      ;; straight-check-for-modifications '(check-on-save find-when-checking)
      straight-check-for-modifications nil)

(unless (featurep 'straight)
  (defvar bootstrap-version)

  (let ((bootstrap-file (concat user-emacs-directory
                                "straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage)))

;; (defun +set-github-mirror (oldfunc &rest args)
;;   (let ((url (apply oldfunc args)))
;;     (replace-regexp-in-string (rx (group "github.com"))
;;                               "hub.fastgit.org" url nil nil 1)))
;; (advice-add 'straight-vc-git--encode-url :around #'+set-github-mirror)

(add-to-list 'straight-built-in-pseudo-packages 'eglot)
(add-to-list 'straight-built-in-pseudo-packages 'tramp)
(add-to-list 'straight-built-in-pseudo-packages 'use-package)
(add-to-list 'straight-built-in-pseudo-packages 'project)
(add-to-list 'straight-built-in-pseudo-packages 'org)
(add-to-list 'straight-built-in-pseudo-packages 'xref)
;; -Straight

(defun +my/check-straight-repos ()
  (interactive)
  (find-file (read-file-name "Repos: " "~/.emacs.d/straight/repos/")))
#+end_src

** Benchmark
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
#+begin_src emacs-lisp
(use-package benchmark-init
  :demand t
  :config
  (add-hook '+my/first-input-hook 'benchmark-init/deactivate))
#+end_src
* Global Configuration
#+begin_src emacs-lisp
;; UTF8Coding
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(when *sys/gui*
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
;; -UTF8Coding

(setq default-directory (concat (getenv "HOME") "/"))

;; Remove useless whitespace before saving a file
(defun delete-trailing-whitespace-except-current-line ()
  "An alternative to `delete-trailing-whitespace'.

The original function deletes trailing whitespace of the current line."
  (interactive)
  (let ((begin (line-beginning-position))
        (end (line-end-position)))
    (save-excursion
      (when (< (point-min) (1- begin))
        (save-restriction
          (narrow-to-region (point-min) (1- begin))
          (delete-trailing-whitespace)
          (widen)))
      (when (> (point-max) (+ end 2))
        (save-restriction
          (narrow-to-region (+ end 2) (point-max))
          (delete-trailing-whitespace)
          (widen))))))

(add-hook 'before-save-hook #'delete-trailing-whitespace-except-current-line)

;; Replace selection on insert
(delete-selection-mode 1)

;; Map Alt key to Meta
(setq x-alt-keysym 'meta)
(setq mac-command-modifier 'meta) ; make cmd key do Meta
(setq mac-option-modifier 'super) ; make opt key do Super
(setq mac-control-modifier 'control) ; make Control key do Control
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper

;; When buffer is closed, saves the cursor location
(save-place-mode 1)

;; Set history-length longer
(setq-default history-length 500)
;; -History

;; SmallConfigs
;; Turn Off Cursor Alarms
(setq ring-bell-function 'ignore)

;; Show Keystrokes in Progress Instantly
(setq echo-keystrokes 0.1)

;; Don't Lock Files
(setq create-lockfiles nil)
(setq make-backup-files nil)
(setq auto-save-default nil)

;; Better Compilation
(setq-default compilation-always-kill t) ; kill compilation process before starting another

(setq-default compilation-ask-about-save nil) ; save all buffers on `compile'

(setq-default compilation-scroll-output t)

;; ad-handle-definition warnings are generated when functions are redefined with `defadvice',
;; they are not helpful.
(setq ad-redefinition-action 'accept)

;; Move Custom-Set-Variables to Different File
(setq custom-file (concat user-emacs-directory "custom-set-variables.el"))
(load custom-file 'noerror)

;; So Long mitigates slowness due to extremely long lines.
;; Currently available in Emacs master branch *only*!
(when (fboundp 'global-so-long-mode)
  (global-so-long-mode))

;; Add a newline automatically at the end of the file upon save.
(setq require-final-newline t)

;; Default .args, .in, .out files to text-mode
(add-to-list 'auto-mode-alist '("\\.in\\'" . text-mode))
(add-to-list 'auto-mode-alist '("\\.out\\'" . text-mode))
(add-to-list 'auto-mode-alist '("\\.args\\'" . text-mode))
;; -SmallConfigs

;; Sync my code on save
(defmacro η (fnc)
  "Return function that ignores its arguments and invokes FNC."
  `(lambda (&rest _rest)
     (funcall ,fnc)))
(when +self/use-rc-to-sync
  (advice-add #'save-buffer :after (η
                                    (lambda ()
                                      (when (derived-mode-p 'prog-mode)
                                        (call-process-shell-command "rc" nil 0))))))

;; _ as part of a word
(modify-syntax-entry ?_ "w")
(defalias 'forward-evil-word 'forward-evil-symbol)

;; Don't ping things that look like domain names.
(setq command-line-ns-option-alist nil)

(setq vc-follow-symlinks t)


;; Disable message for some functions
(defun suppress-message-advice-around (fun &rest args)
  (let (message-log-max)
    (with-temp-message (or (current-message) "")
      (apply fun args))))
(advice-add 'save-buffer :around 'suppress-message-advice-around)

(defun filter-command-error-function (data context caller)
  "Ignore the buffer-read-only, beginning-of-line, end-of-line, beginning-of-buffer, end-of-buffer signals; pass the rest to the default handler."
  (when (not (memq (car data) '(buffer-read-only
                                beginning-of-line
                                end-of-line
                                beginning-of-buffer
                                end-of-buffer)))
    (command-error-default-function data context caller)))

(setq command-error-function #'filter-command-error-function)

(dolist (hook '(conf-mode-hook conf-space-mode-hook emacs-lisp-mode-hook))
  (add-hook hook #'hexcolour-add-to-font-lock))

(setq-default which-func-modes '(emacs-lisp-mode python-mode org-mode latex-mode))
(which-function-mode +1)

(add-hook 'after-init-hook (lambda ()
                             (run-with-idle-timer 5 nil
                                                  (lambda ()
                                                    (server-start)))))
#+end_src
* Helper Functions
#+begin_src emacs-lisp
;;;###autoload
(defun +my/kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

;;;###autoload
(defun +my/imenu ()
  "Consult-outline in `org-mode' unless imenu."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (consult-org-heading)
    (consult-imenu)))

;;;###autoload
(defun +my/rename-file()
  "Rename file while using current file as default."
  (interactive)
  (let ((file-from (read-file-name "Move from: " default-directory buffer-file-name))
        (file-to (read-file-name "Move to:" default-directory)))
    (rename-file file-from file-to)
    (when (string= (file-truename file-from) (file-truename (buffer-file-name)))
      (kill-buffer)
      (find-file file-to))))

;;;###autoload
(defun +my/delete-file ()
  "Put current buffer file to top."
  (interactive)
  (delete-file
   (read-file-name "Delete: " default-directory buffer-file-name))
  (unless (file-exists-p (buffer-file-name))
    (kill-current-buffer)))


;;;###autoload
(defun +my/open-recent ()
  "Open recent directory in Dired or file otherwise."
  (interactive)
  (unless recentf-mode (recentf-mode 1))
  (let* ((candidates (if (derived-mode-p 'dired-mode)
                         (delete-dups
                          (append (mapcar 'file-name-directory recentf-list))
                          ;; (append (mapcar (lambda (fname) (string-join (butlast (string-split fname "/")) "/")) recentf-list))
                          )
                       (mapcar #'abbreviate-file-name
                               ;; (-filter (lambda (filename) (not (file-directory-p filename)))
                               (-filter (lambda (filename) (not (string= "/" (substring filename -1))))
                                        recentf-list)))))
    (find-file
     (consult--read
      candidates
      :prompt "Find recent file: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history
      ))))

;;;###autoload
(defun +my/project-root (&optional dir)
  "Return the project root of DIR."
  (when-let* ((default-directory (or dir default-directory))
              (project (project-current)))
    (expand-file-name (if (fboundp 'project-root)
                          (project-root project)
                        (cdr project)))))

;;;###autoload
(defun +my/save-file ()
  "Save files including org agenda"
  (interactive)
  (if (derived-mode-p 'org-agenda-mode)
      (org-save-all-org-buffers)
    (save-buffer)))


;;;###autoload
(defun hexcolour-luminance (color)
  "Calculate the luminance of a COLOR string (e.g. \"#ffaa00\", \"blue\").
  This is 0.3 red + 0.59 green + 0.11 blue and always between 0 and 255."
  (let* ((values (x-color-values color))
         (r (car values))
         (g (cadr values))
         (b (caddr values)))
    (floor (+ (* .3 r) (* .59 g) (* .11 b)) 256)))

;;;###autoload
(defun hexcolour-add-to-font-lock ()
  (interactive)
  (font-lock-add-keywords
   nil
   `((,(concat "#[0-9a-fA-F]\\{3\\}[0-9a-fA-F]\\{3\\}?\\|"
               (regexp-opt (x-defined-colors) 'words))
      (0 (let ((colour (match-string-no-properties 0)))
           (put-text-property
            (match-beginning 0) (match-end 0)
            'face `((:foreground ,(if (> 128.0 (hexcolour-luminance colour))
                                      "white" "black"))
                    (:background ,colour)))))))))

;;;###autoload
(defvar +my/profiler--started nil)
(defun +my/profiler-toggle ()
  "Start ro stop profiler."
  (interactive)
  (if +my/profiler--started
      (progn
        (profiler-stop)
        (profiler-report)
        (setq +my/profiler--started nil))
    (profiler-start 'cpu+mem)
    (setq +my/profiler--started t)))


;;;###autoload
(defun +my/google-it (&optional word)
  "Google WORD"
  (interactive (list
                (if (use-region-p)
                    (buffer-substring-no-properties (region-beginning)
                                                    (region-end))
                  (thing-at-point 'symbol))))
  (browse-url (concat "https://www.google.com/search?q=" word)))

;;;###autoload
(defun +my/replace (&optional word)
  "Make it eary to use `:%s' to replace WORD."
  (interactive (list
                (if (use-region-p)
                    (buffer-substring-no-properties (region-beginning) (region-end))
                  (thing-at-point 'symbol))))
  (let* ((word (replace-regexp-in-string "\\\\" "\\\\\\\\" word))
         (word (replace-regexp-in-string "/" "\\\\/" word)))
    (evil-ex (concat "%s/" word "/" word))))

(defun +my/open-in-osx-finder (file)
  "Open FILE in `Finder'"
  (interactive "GFile: ")
  (let* ((file (expand-file-name file))
         (script (concat
	              "set thePath to POSIX file \"" file "\"\n"
	              "tell application \"Finder\"\n"
	              " set frontmost to true\n"
	              " reveal thePath \n"
	              "end tell\n")))
    (start-process "osascript-getinfo" nil "osascript" "-e" script)))

(defun +my/quick-look (&optional file)
  "Open FILE with quick look"
  (interactive
   (list
    (if (derived-mode-p 'dired-mode)
        (car (dired-get-marked-files))
      (read-file-name "File:" default-directory buffer-file-name))))
  (call-process-shell-command (concat "qlmanage -p \"" (expand-file-name file) "\"")))
#+end_src
* Evil
#+begin_src emacs-lisp
(use-package evil
  :hook (after-init . evil-mode)
  :demand t
  :init
  (setq evil-want-keybinding nil)
  :preface
  (setq evil-want-visual-char-semi-exclusive t
        evil-ex-search-vim-style-regexp t
        evil-ex-substitute-global t
        evil-ex-visual-char-range t  ; column range for ex commands
        evil-mode-line-format 'nil
        ;; more vim-like behavior
        evil-symbol-word-search t
        ;; cursor appearance
        evil-normal-state-cursor 'box
        evil-insert-state-cursor 'bar
        evil-visual-state-cursor 'hollow
        evil-want-keybinding 'nil
        ;; Only do highlighting in selected window so that Emacs has less work
        ;; to do highlighting them all.
        evil-ex-interactive-search-highlight 'selected-window
        evil-split-window-below t
        evil-vsplit-window-right t
        evil-undo-system 'undo-redo)

  :config
  (evil-select-search-module 'evil-search-module 'evil-search)
  (put 'evil-define-key* 'lisp-indent-function 'defun)

  ;; stop copying each visual state move to the clipboard:
  ;; https://bitbucket.org/lyro/evil/issue/336/osx-visual-state-copies-the-region-on
  ;; grokked from:
  ;; http://stackoverflow.com/questions/15873346/elisp-rename-macro
  (advice-add #'evil-visual-update-x-selection :override #'ignore)

  ;; Start help-with-tutorial in emacs state
  (advice-add #'help-with-tutorial :after (lambda (&rest _) (evil-emacs-state +1)))

  ;; Allows you to click buttons without initiating a selection
  (define-key evil-motion-state-map [down-mouse-1] nil)

  (with-eval-after-load 'general
    (general-define-key :keymaps 'evil-window-map
                        "C-h" 'evil-window-left
                        "C-j" 'evil-window-down
                        "C-k" 'evil-window-up
                        "C-l" 'evil-window-right))
  )
#+end_src
** Evil related packages
#+begin_src emacs-lisp
(use-package evil-embrace
  :after evil
  :commands (embrace-add-pair embrace-add-pair-regexp)
  :config
  (add-hook 'LaTeX-mode-hook 'embrace-LaTeX-mode-hook)
  (add-hook 'org-mode-hook 'embrace-org-mode-hook)
  (add-hook 'emacs-lisp-mode-hook 'embrace-emacs-lisp-mode-hook)

  ;; Add escaped-sequence support to embrace
  (setf (alist-get ?\\ (default-value 'embrace--pairs-list))
        (make-embrace-pair-struct
         :key ?\\
         :left-regexp "\\[[{(]"
         :right-regexp "\\[]})]"))
  (evil-surround-mode)
  (evil-embrace-enable-evil-surround-integration)
  )


(use-package evil-escape
  :after evil
  :hook (+my/first-input . evil-escape-mode)
  :commands (evil-escape-pre-command-hook)
  :init
  (setq evil-escape-excluded-states '(normal visual multiedit emacs motion)
        evil-escape-excluded-major-modes '(vterm-mode)
        evil-escape-key-sequence "jk"
        evil-escape-delay 0.15)
  (evil-define-key* '(insert replace visual operator) 'global "\C-g" #'evil-escape)
  (add-hook 'pre-command-hook 'evil-escape-pre-command-hook)
  :config
  ;; no `evil-escape' in minibuffer
  (add-hook 'evil-escape-inhibit-functions #'minibufferp)
  )



(use-package evil-nerd-commenter
  :commands (evilnc-comment-operator
             evilnc-inner-comment
             evilnc-outer-commenter
             evilnc-comment-or-uncomment-lines))

;; for visualization like substitute
(use-package evil-traces
  :after evil-ex
  :hook (+my/first-input . evil-traces-mode))

;; Allows you to use the selection for * and #
(use-package evil-visualstar
  :after evil
  :commands (evil-visualstar/begin-search
             evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-backward)
  :init
  (evil-define-key* 'visual 'global
    "*" #'evil-visualstar/begin-search-forward
    "#" #'evil-visualstar/begin-search-backward))


(use-package evil-collection
  :defer nil
  :after evil
  :init
  (setq evil-want-keybinding nil)
  :config
  ;;  TODO: init when loading specific package
  (let ((modes '(atomic-chrome calc calendar consult devdocs diff-hl diff-mode dired doc-view ebib edebug ediff eglot eldoc elisp-mode eval-sexp-fu evil-mc flymake  git-timemachine gnus grep help helpful buffer image image-dired image+ imenu imenu-list (indent "indent")  info log-view man (magit magit-repos magit-submodule) magit-section magit-todos markdown-mode mu4e mu4e-conversation org (pdf pdf-view) popup proced (process-menu simple) profiler python reftex replace rtags sh-script shortdoc so-long tab-bar tablist tabulated-list tar-mode thread tide timer-list vc-annotate vc-dir vc-git vdiff vertico view vterm vundo wdired wgrep which-key xref yaml-mode (ztree ztree-diff ztree-dir))))
    (evil-collection-init modes))
  )

;; indent textobj
(use-package evil-indent-plus
  :after evil
  :hook (+my/first-input . evil-indent-plus-default-bindings)
  :commands (evil-indent-plus-default-bindings))
;; in/decrease number
;; (use-package evil-numbers)

(use-package evil-anzu
  :after evil
  :after-call evil-ex-search-next
  :config
  (global-anzu-mode)
  (add-hook 'evil-insert-state-entry-hook #'evil-ex-nohighlight)
  )

(use-package evil-textobj-tree-sitter
  :after (tree-sitter evil)
  :straight (evil-textobj-tree-sitter :type git :host github :repo "meain/evil-textobj-tree-sitter" :files (:defaults "queries"))
  :config
  ;; bind `function.outer`(entire function block) to `f` for use in things like `vaf`, `yaf`
  (define-key evil-outer-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.outer"))
  ;; bind `function.inner`(function block without name and args) to `f` for use in things like `vif`, `yif`
  (define-key evil-inner-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.inner"))

  (define-key evil-outer-text-objects-map "c" (evil-textobj-tree-sitter-get-textobj "class.outer"))
  (define-key evil-inner-text-objects-map "c" (evil-textobj-tree-sitter-get-textobj "class.inner"))

  ;; You can also bind multiple items and we will match the first one we can find
  (define-key evil-outer-text-objects-map "a" (evil-textobj-tree-sitter-get-textobj ("conditional.outer" "loop.outer")))

  ;; function
  ;; Goto start of next function
  (define-key evil-normal-state-map (kbd "]f") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "function.outer")))
  ;; Goto start of previous function
  (define-key evil-normal-state-map (kbd "[f") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "function.outer" t)))
  ;; Goto end of next function
  (define-key evil-normal-state-map (kbd "]F") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "function.outer" nil t)))
  ;; Goto end of previous function
  (define-key evil-normal-state-map (kbd "[F") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "function.outer" t t)))
  ;; class
  ;; Goto start of next class
  (define-key evil-normal-state-map (kbd "]c") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "class.outer")))
  ;; Goto start of previous class
  (define-key evil-normal-state-map (kbd "[c") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "class.outer" t)))
  ;; Goto end of next class
  (define-key evil-normal-state-map (kbd "]C") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "class.outer" nil t)))
  ;; Goto end of previous class
  (define-key evil-normal-state-map (kbd "[C") (lambda ()
                                                 (interactive)
                                                 (evil-textobj-tree-sitter-goto-textobj "class.outer" t t)))
  )

(use-package evil-mc
  ;;  FIXME: still not easy to use, need finetune
  :after evil
  :hook (+my/first-input . global-evil-mc-mode)
  :config
  (global-set-key (kbd "s-<mouse-1>") 'evil-mc-toggle-cursor-on-click)
  )
#+end_src
* Search
** English
#+begin_src emacs-lisp
(use-package youdao-dictionary
  :commands youdao-dictionary-play-voice-of-current-word
  :init
  (setq url-automatic-caching t
        youdao-dictionary-use-chinese-word-segmentation t) ; 中文分词

  (defun +my/youdao-search-at-point ()
    "Search word at point and display result with `posframe', `pos-tip', or buffer."
    (interactive)
    (if (display-graphic-p)
        (youdao-dictionary-search-at-point-posframe)
      (youdao-dictionary-search-at-point))))

(use-package multi-translate
  :straight (:host github :repo "twlz0ne/multi-translate.el")
  :commands (multi-translate multi-translate-at-point multi-translate-yank-at-point)
  :custom
  (multi-translate-sentence-backends '(google))
  (multi-translate-word-backends '(bing youdao))
  :config
  (defun multi-translate-yank-at-point (arg)
    ;;  FIXME: for thesis
    "Used temporarily for thesis"
    (interactive "P")
    (let* ((bounds (if (region-active-p)
                       (cons (region-beginning) (region-end))
                     (bounds-of-thing-at-point 'word)))
           (text (string-trim (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (kill-new (multi-translate--google-translation "en" "zh-CN" text))
      (evil-normal-state)
      (message "Translate Done")))

  (defun multi-translate-yank-at-point-and-paste-to-right (arg)
    ;;  FIXME: for thesis
    "Used temporarily for thesis"
    (interactive "P")
    (let* ((bounds (if (region-active-p)
                       (cons (region-beginning) (region-end))
                     (bounds-of-thing-at-point 'word)))
           (text (string-trim (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (kill-new (multi-translate--google-translation "en" "zh-CN" text))
      (evil-normal-state)
      (evil-window-right 1)
      (end-of-buffer)
      (evil-paste-after 1)
      (evil-window-left 1)
      (message "Translate Done")))

  )
#+end_src
** Look up
#+begin_src emacs-lisp
;;
;;; Helpers

(defun +lookup--run-handler (handler identifier)
  (if (commandp handler)
      (call-interactively handler)
    (funcall handler identifier)))

(defun +lookup--run-handlers (handler identifier origin)
  (message "Looking up '%s' with '%s'" identifier handler)
  (condition-case-unless-debug e
      (let ((wconf (current-window-configuration))
            (result (condition-case-unless-debug e
                        (+lookup--run-handler handler identifier)
                      (error
                       (message "Lookup handler %S threw an error: %s" handler e)
                       'fail))))
        (cond ((eq result 'fail)
               (set-window-configuration wconf)
               nil)
              ((or (get handler '+lookup-async)
                   (eq result 'deferred)))
              ((or result
                   (null origin)
                   (/= (point-marker) origin))
               (prog1 (point-marker)
                 (set-window-configuration wconf)))))
    ((error user-error)
     (message "Lookup handler %S: %s" handler e)
     nil)))

(defun +lookup--jump-to (prop identifier &optional display-fn arg)
  (let* ((origin (point-marker))
         (handlers
          (plist-get (list :definition '+lookup-definition-functions
                           :implementations '+lookup-implementations-functions
                           :type-definition '+lookup-type-definition-functions
                           :references '+lookup-references-functions
                           :documentation '+lookup-documentation-functions
                           :file '+lookup-file-functions)
                     prop))
         (result
          (if arg
              (if-let
                  (handler
                   (intern-soft
                    (completing-read "Select lookup handler: "
                                     (delete-dups
                                      (remq t (append (symbol-value handlers)
                                                      (default-value handlers))))
                                     nil t)))
                  (+lookup--run-handlers handler identifier origin)
                (user-error "No lookup handler selected"))
            (run-hook-wrapped handlers #'+lookup--run-handlers identifier origin))))
    (unwind-protect
        (when (cond ((null result)
                     (message "No lookup handler could find %S" identifier)
                     nil)
                    ((markerp result)
                     (funcall (or display-fn #'switch-to-buffer)
                              (marker-buffer result))
                     (goto-char result)
                     result)
                    (result))
          (with-current-buffer (marker-buffer origin)
            (better-jumper-set-jump (marker-position origin)))
          result)
      (set-marker origin nil))))


;;
;;; Lookup backends

(autoload 'xref--show-defs "xref")
(defun +lookup--xref-show (fn identifier &optional show-fn)
  (let ((xrefs (funcall fn
                        (xref-find-backend)
                        identifier)))
    (when xrefs
      (let* ((jumped nil)
             (xref-after-jump-hook
              (cons (lambda () (setq jumped t))
                    xref-after-jump-hook)))
        (funcall (or show-fn #'xref--show-defs)
                 (lambda () xrefs)
                 nil)
        (if (cdr xrefs)
            'deferred
          jumped)))))

(defun +lookup-xref-definitions-backend-fn (identifier)
  "Non-interactive wrapper for `xref-find-definitions'"
  (condition-case _
      (+lookup--xref-show 'xref-backend-definitions identifier #'xref--show-defs)
    (cl-no-applicable-method nil)))

(defun +lookup-xref-references-backend-fn (identifier)
  "Non-interactive wrapper for `xref-find-references'"
  (condition-case _
      (+lookup--xref-show 'xref-backend-references identifier #'xref--show-xrefs)
    (cl-no-applicable-method nil)))

(defun +lookup-dumb-jump-backend-fn (_identifier)
  "Look up the symbol at point (or selection) with `dumb-jump', which conducts a
project search with ag, rg, pt, or git-grep, combined with extra heuristics to
reduce false positives.
This backend prefers \"just working\" over accuracy."
  (and (require 'dumb-jump nil t)
       (dumb-jump-go)))

(defun +lookup-project-search-backend-fn (identifier)
  (when identifier
    (+consult-ripgrep-at-point (+my/project-root) identifier)
    t))

(defun +lookup-ffap-backend-fn (identifier)
  (require 'ffap)
  (let ((guess
         (cond ((doom-region-active-p)
                (buffer-substring-no-properties
                 (doom-region-beginning)
                 (doom-region-end)))
               ((ffap-guesser))
               ((thing-at-point 'filename t))
               (identifier))))
    (when (and (stringp guess)
               (or (file-exists-p guess)
                   (ffap-url-p guess)))
      (find-file-at-point guess))))

;;
;;; Main commands

;;;###autoload
(defun +lookup/definition (identifier &optional arg)
  "Jump to the definition of IDENTIFIER (defaults to the symbol at point).
Each function in `+lookup-definition-functions' is tried until one changes the
point or current buffer. Falls back to dumb-jump, naive
ripgrep/the_silver_searcher text search, then `evil-goto-definition' if
evil-mode is active."
  (interactive (list (doom-thing-at-point-or-region)
                     current-prefix-arg))
  (cond ((null identifier) (user-error "Nothing under point"))
        ((+lookup--jump-to :definition identifier nil arg))
        ((error "Couldn't find the definition of %S" identifier))))

;;;###autoload
(defun +lookup/references (identifier &optional arg)
  "Show a list of usages of IDENTIFIER (defaults to the symbol at point)
Tries each function in `+lookup-references-functions' until one changes the
point and/or current buffer. Falls back to a naive ripgrep/the_silver_searcher
search otherwise."
  (interactive (list (doom-thing-at-point-or-region)
                     current-prefix-arg))
  (cond ((null identifier) (user-error "Nothing under point"))
        ((+lookup--jump-to :references identifier nil arg))
        ((error "Couldn't find references of %S" identifier))))


;;;###autoload
(defun doom-region-active-p ()
  "Return non-nil if selection is active.
Detects evil visual mode as well."
  (declare (side-effect-free t))
  (or (use-region-p)
      (and (bound-and-true-p evil-local-mode)
           (evil-visual-state-p))))


;;;###autoload
(defun doom-region-beginning ()
  "Return beginning position of selection.
Uses `evil-visual-beginning' if available."
  (declare (side-effect-free t))
  (or (and (bound-and-true-p evil-local-mode)
           (markerp evil-visual-beginning)
           (marker-position evil-visual-beginning))
      (region-beginning)))

;;;###autoload
(defun doom-region-end ()
  "Return end position of selection.
Uses `evil-visual-end' if available."
  (declare (side-effect-free t))
  (if (bound-and-true-p evil-local-mode)
      evil-visual-end
    (region-end)))

;;;###autoload
(defun doom-thing-at-point-or-region (&optional thing prompt)
  "Grab the current selection, THING at point, or xref identifier at point.
Returns THING if it is a string. Otherwise, if nothing is found at point and
PROMPT is non-nil, prompt for a string (if PROMPT is a string it'll be used as
the prompting string). Returns nil if all else fails.
NOTE: Don't use THING for grabbing symbol-at-point. The xref fallback is smarter
in some cases."
  (declare (side-effect-free t))
  (cond ((stringp thing)
         thing)
        ((doom-region-active-p)
         (buffer-substring-no-properties
          (doom-region-beginning)
          (doom-region-end)))
        (thing
         (thing-at-point thing t))
        ((require 'xref nil t)
         ;; Eglot, nox (a fork of eglot), and elpy implementations for
         ;; `xref-backend-identifier-at-point' betray the documented purpose of
         ;; the interface. Eglot/nox return a hardcoded string and elpy prepends
         ;; the line number to the symbol.
         (if (memq (xref-find-backend) '(eglot elpy nox))
             (thing-at-point 'symbol t)
           ;; A little smarter than using `symbol-at-point', though in most
           ;; cases, xref ends up using `symbol-at-point' anyway.
           (xref-backend-identifier-at-point (xref-find-backend))))
        (prompt
         (read-string (if (stringp prompt) prompt "")))))
#+end_src

#+begin_src emacs-lisp
(defvar +lookup-definition-functions
  '(+lookup-xref-definitions-backend-fn
    +lookup-dumb-jump-backend-fn
    +lookup-ffap-backend-fn
    +lookup-project-search-backend-fn))

(defvar +lookup-references-functions
  '(+lookup-xref-references-backend-fn
    +lookup-project-search-backend-fn))

;;
;;; dumb-jump

(use-package dumb-jump
  :commands dumb-jump-result-follow
  :config
  (setq dumb-jump-default-project "~/.emacs.d/"
        dumb-jump-prefer-searcher 'rg
        dumb-jump-aggressive nil
        dumb-jump-quiet t
        dumb-jump-selector 'completing-read)
  (add-hook 'dumb-jump-after-jump-hook #'better-jumper-set-jump))

;;
;;; xref
(use-package xref
  :straight nil
  :init
  (setq xref-search-program 'ripgrep)
  (setq xref-show-xrefs-function #'xref-show-definitions-completing-read)
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
  :hook ((xref-after-return xref-after-jump) . recenter))


;; The lookup commands are superior, and will consult xref if there are no
;; better backends available.
(global-set-key [remap xref-find-definitions] #'+lookup/definition)
(global-set-key [remap xref-find-references]  #'+lookup/references)

(use-package better-jumper
  :hook (+my/first-input . better-jumper-mode)
  :commands doom-set-jump-a
  :preface
  ;; REVIEW Suppress byte-compiler warning spawning a *Compile-Log* buffer at
  ;; startup. This can be removed once gilbertw1/better-jumper#2 is merged.
  (defvar better-jumper-local-mode nil)
  :init
  (global-set-key [remap evil-jump-forward]  #'better-jumper-jump-forward)
  (global-set-key [remap evil-jump-backward] #'better-jumper-jump-backward)
  (global-set-key [remap xref-pop-marker-stack] #'better-jumper-jump-backward)
  :config
  (defun doom-set-jump-a (fn &rest args)
    "Set a jump point and ensure fn doesn't set any new jump points."
    (better-jumper-set-jump (if (markerp (car args)) (car args)))
    (let ((evil--jumps-jumping t)
          (better-jumper--jumping t))
      (apply fn args)))

  (mapcar
   (lambda (fn)
     (advice-add fn :around #'doom-set-jump-a))
   (list #'kill-current-buffer #'+my/imenu #'+my/consult-line
         #'find-file #'+my/consult-line-symbol-at-point #'consult-fd #'consult-ripgrep
         #'+consult-ripgrep-at-point))
  )

(with-eval-after-load 'xref
  (remove-hook 'xref-backend-functions #'etags--xref-backend)
  ;; This integration is already built into evil
  ;; Use `better-jumper' instead of xref's marker stack
  (advice-add #'xref-push-marker-stack :around #'doom-set-jump-a)
  )

(use-package avy

  :commands (avy-goto-char avy-goto-line))

(use-package wgrep)
#+end_src

* Completion
** Vertico
#+begin_src emacs-lisp
(use-package pinyinlib
  :after orderless
  :after-call +my/first-input-hook-fun
  :config
  (defun completion--regex-pinyin (str)
    (orderless-regexp (pinyinlib-build-regexp-string str)))
  (add-to-list 'orderless-matching-styles 'completion--regex-pinyin)
  )


(autoload 'ffap-file-at-point "ffap")

(use-package embark
  :straight (embark :files (:defaults "*.el"))
  :after-call +my/first-input-hook-fun
  :after general
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("M-." . embark-dwim)
   ("C-/" . embark-export)
   ("C-h B" . embark-bindings) ;; alternative for `describe-bindings'
   :map embark-file-map
   ("r" . +my/rename-file)
   ("d" . +my/delete-file)
   ("X" . +my/open-in-osx-finder)
   ("SPC" . +my/quick-look)
   :map embark-identifier-map
   (";" . embrace-commander)
   :map embark-region-map
   (";" . embrace-commander)
   )
  :custom
  (embark-cycle-key ".")
  (embark-help-key "?")
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  ;;  HACK: bind will be override by evil
  (general-define-key :states '(normal insert visual emacs)
                      "C-." 'embark-act
                      "M-." 'embark-dwim
                      "C-h B" 'embark-bindings)

  (setq embark-candidate-collectors
        (cl-substitute 'embark-sorted-minibuffer-candidates
                       'embark-minibuffer-candidates
                       embark-candidate-collectors))
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)
  )


(use-package embark-consult
  :ensure t ; only
  :after consult)

(use-package vertico
  :straight (vertico :includes (vertico-quick vertico-repeat vertico-directory) :files (:defaults "extensions/vertico-*.el"))
  :hook (window-setup . vertico-mode)
  :config
  (setq vertico-cycle nil
        vertico-preselect 'first)

  (defun +vertico-restrict-to-matches ()
    (interactive)
    (let ((inhibit-read-only t))
      (goto-char (point-max))
      (insert " ")
      (add-text-properties (minibuffer-prompt-end) (point-max)
                           '(invisible t read-only t cursor-intangible t rear-nonsticky t))))
  (define-key vertico-map (kbd "S-SPC") #'+vertico-restrict-to-matches)

  (defun +vertico/jump-list (jump)
    "Go to an entry in evil's (or better-jumper's) jumplist."
    (interactive
     (let (buffers)
       (unwind-protect
           (list
            (consult--read
             ;; REVIEW Refactor me
             (nreverse
              (delete-dups
               (delq
                nil (mapcar
                     (lambda (mark)
                       (when mark
                         (cl-destructuring-bind (path pt _id) mark
                           (let* ((visiting (find-buffer-visiting path))
                                  (buf (or visiting (find-file-noselect path t)))
                                  (dir default-directory))
                             (unless visiting
                               (push buf buffers))
                             (with-current-buffer buf
                               (goto-char pt)
                               (font-lock-fontify-region
                                (line-beginning-position) (line-end-position))
                               (format "%s:%d: %s"
                                       (car (cl-sort (list (abbreviate-file-name (buffer-file-name buf))
                                                           (file-relative-name (buffer-file-name buf) dir))
                                                     #'< :key #'length))
                                       (line-number-at-pos)
                                       (string-trim-right (or (thing-at-point 'line) ""))))))))
                     (cddr (better-jumper-jump-list-struct-ring
                            (better-jumper-get-jumps (better-jumper--get-current-context))))))))
             :prompt "jumplist: "
             :sort nil
             :require-match t
             :category 'jump-list))
         (mapc #'kill-buffer buffers))))
    (if (not (string-match "^\\([^:]+\\):\\([0-9]+\\): " jump))
        (user-error "No match")
      (let ((file (match-string-no-properties 1 jump))
            (line (match-string-no-properties 2 jump)))
        (find-file file)
        (goto-char (point-min))
        (forward-line (string-to-number line)))))

  (use-package vertico-quick
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("M-q" . vertico-quick-insert)
                ("C-q" . vertico-quick-exit)))
  (use-package vertico-repeat
    :after vertico
    :ensure nil
    :bind ("C-c r" . vertico-repeat)
    :hook (minibuffer-setup . vertico-repeat-save)
    )
  (use-package vertico-directory
    :after vertico
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
                ;; ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("C-w" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
  )

;; A few more useful configurations...
(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; Alternatively try `consult-completing-read-multiple'.
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))


(use-package consult
  :demand t
  :after orderless
  :straight (:host github :repo "minad/consult")
  :bind (
         ([remap recentf-open-files] . consult-recent-file)
         ([remap imenu] . consult-imenu)
         ([remap switch-to-buffer] . consult-buffer)
         ("M-g o" . consult-outline)
         ("M-g h" . consult-org-heading)
         ("M-g a" . consult-org-agenda)
         ("<help> a" . consult-apropos)
         ("M-s m" . consult-multi-occur)
         )
  :init
  :config
  (setq consult-preview-key "M-.")
  (setq consult-narrow-key "<")

  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; consult-imenu
  (with-eval-after-load 'consult-imenu
    (add-to-list 'consult-imenu-config '(python-mode :types
                                                     ((?c "Class"    font-lock-type-face)
                                                      (?C "Constant"    font-lock-constant-face)
                                                      (?f "Function"  font-lock-function-name-face)
                                                      (?m "Method"  font-lock-function-name-face)
                                                      (?v "Variable"  font-lock-variable-name-face))))
    (add-to-list 'consult-imenu-config '(latex-mode :types
                                                    ((?c "Class"    font-lock-type-face)
                                                     (?C "Constant"    font-lock-constant-face)
                                                     (?f "Function"  font-lock-function-name-face)
                                                     (?m "Method"  font-lock-function-name-face)
                                                     (?M "Module"  font-lock-type-face)
                                                     (?v "Variable"  font-lock-variable-name-face))))
    )

  (defun +my/consult-set-evil-search-pattern (&optional condition)
    (let ((re
           (cond
            ((eq condition 'rg) (substring (car consult--grep-history) 1)) ;; HACK: assume the history begins with `#'
            ((or t (eq condition 'line)) (car consult--line-history)))))
      (add-to-history 'evil-ex-search-history re)
      (setq evil-ex-search-pattern (list re t t))
      (setq evil-ex-search-direction 'forward)
      (anzu-mode t)))

  (defun +my/consult-line-symbol-at-point ()
    (interactive)
    (evil-without-repeat ;; I use evil always
      (consult-line (thing-at-point 'symbol))
      (+my/consult-set-evil-search-pattern)))

  (defun +my/consult-line ()
    (interactive)
    (evil-without-repeat ;; I use evil always
      (consult-line)
      (+my/consult-set-evil-search-pattern)))

  (setq consult-ripgrep-args
        "rga --null --line-buffered --color=never --max-columns=1000 --path-separator /\
   --smart-case --no-heading --line-number .")

  (defun +consult-ripgrep-at-point (&optional dir initial)
    (interactive (list prefix-arg (when-let ((s (symbol-at-point)))
                                    (symbol-name s))))
    (consult-ripgrep dir initial))

  ;; HACK add `ignore' according to upstream, wihout meaning
  (defun consult--orderless-regexp-compiler (input type igore)
    (setq input (orderless-pattern-compiler input))
    (cons
     (mapcar (lambda (r) (consult--convert-regexp r type)) input)
     (lambda (str) (orderless--highlight input str))))
  (defun consult--with-orderless (&rest args)
    (minibuffer-with-setup-hook
        (lambda ()
          (setq-local consult--regexp-compiler #'consult--orderless-regexp-compiler))
      (apply args)))
  (advice-add #'consult-ripgrep :around #'consult--with-orderless)

  (defvar consult--fd-command nil)
  (defun consult--fd-builder (input)
    (unless consult--fd-command
      (setq consult--fd-command
            (if (eq 0 (call-process-shell-command "fdfind"))
                "fdfind"
              "fd")))
    (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                 (`(,re . ,hl) (funcall consult--regexp-compiler
                                        arg 'extended t)))
      (when re
        (list :command (append
                        (list consult--fd-command
                              "--color=never" "--full-path"
                              (consult--join-regexps re 'extended))
                        opts)
              :highlight hl))))

  (defun consult-fd (&optional dir initial)
    (interactive "P")
    (let* ((prompt-dir (consult--directory-prompt "Fd" dir))
           (default-directory (cdr prompt-dir)))
      (find-file (consult--find (car prompt-dir) #'consult--fd-builder initial))))

  ;; Shorten candidates in consult-buffer:
  ;; See: https://emacs-china.org/t/21-emacs-vertico-orderless-marginalia-embark-consult/19683/50
  (defun vmacs-consult--source-recentf-items ()
    (let ((ht (consult--buffer-file-hash))
          file-name-handler-alist ;; No Tramp slowdown please.
          items)
      (dolist (file recentf-list (nreverse items))
        ;; Emacs 29 abbreviates file paths by default, see
        ;; `recentf-filename-handlers'.
        (unless (eq (aref file 0) ?/)
          (setq file (expand-file-name file)))
        (unless (gethash file ht)
          (push (propertize
                 (vmacs-short-filename file)
                 'multi-category `(file . ,file))
                items)))))

  (defun vmacs-short-filename(file)
    "return filename with one parent directory.
/a/b/c/d-> c/d"
    (let* ((file (directory-file-name file))
           (filename (file-name-nondirectory file))
           ;; (dir (file-name-directory file))
           short-name)
      (setq short-name filename
            ;; (if dir
            ;;     (format "%s/%s" (file-name-nondirectory
            ;;                      (directory-file-name dir))
            ;;             filename)
            ;;   filename)
            )
      (propertize short-name 'multi-category `(file . ,file))))

  (defvar recentf-source
    `(:name     "Recent"
                :narrow   ?r
                :face     consult-file
                :category file
                :state    ,#'consult--file-state
                :hidden   nil
                :items    vmacs-consult--source-recentf-items))

  (setq consult-buffer-sources '(consult--source-buffer consult--source-hidden-buffer recentf-source))

  (advice-add 'marginalia--annotate-local-file :override
              (defun marginalia--annotate-local-file-advice (cand)
                (marginalia--fields
                 ((marginalia--full-candidate cand)
                  :face 'marginalia-size ))))
  )

(use-package consult-project-extra
  :after consult
  :straight (consult-project-extra :type git :host github :repo "Qkessler/consult-project-extra")
  )

(use-package consult-dir
  :ensure t
  :after consult
  :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file))
  :config
  (defun consult-dir--zlua-dirs ()
    "Return list of fasd dirs."
    (reverse
     (mapcar
      (lambda (str) (format "%s/" (car (last (split-string str " ")))))
      (split-string (shell-command-to-string "z -l | tail -n 50") "\n" t))))
  (defvar consult-dir--source-zlua
    `(:name     "z.lua dirs"
                :narrow   ?z
                :category file
                :face     consult-file
                :history  file-name-history
                :enabled  ,(lambda () t)  ;;  FIXME: check whether z.lua is installed
                :items    ,#'consult-dir--zlua-dirs)
    "Fasd directory source for `consult-dir'.")
  ;; (add-to-list 'consult-dir-sources 'consult-dir--source-zlua t)
  (setq consult-dir-sources '(consult-dir--source-recentf consult-dir--source-zlua consult-dir--source-project))
  )

(use-package consult-git-log-grep
  :after consult
  :commands consult-git-log-grep
  :straight (:host github :repo "ghosty141/consult-git-log-grep")
  :custom
  (consult-git-log-grep-open-function #'magit-show-commit))


(use-package orderless
  :after-call +my/first-input-hook-fun
  :config
  (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)
      (?! . orderless-without-literal)
      (?`. orderless-initialism)
      (?= . orderless-literal)
      (?~ . orderless-flex)))

  ;; Recognizes the following patterns:
  ;; * ~flex flex~
  ;; * =literal literal=
  ;; * %char-fold char-fold%
  ;; * `initialism initialism`
  ;; * !without-literal without-literal!
  ;; * .ext (file extension)
  ;; * regexp$ (regexp matching at end)
  (defun +orderless-dispatch (pattern index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
     ;; Ignore single !
     ((string= "!" pattern) `(orderless-literal . ""))
     ;; Prefix and suffix
     ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 1))
        (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
          (cons (cdr x) (substring pattern 0 -1)))))))

  ;; Define orderless style with initialism by default
  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  ;; FIX for tramp
  (defun basic-remote-try-completion (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-try-completion string table pred point)))

  (defun basic-remote-all-completions (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-all-completions string table pred point)))

  (add-to-list
   'completion-styles-alist
   '(basic-remote basic-remote-try-completion basic-remote-all-completions nil))

  (setq completion-styles '(orderless)
        completion-category-defaults nil
        ;;; Enable partial-completion for files.
        ;;; Either give orderless precedence or partial-completion.
        ;;; Note that completion-category-overrides is not really an override,
        ;;; but rather prepended to the default completion-styles.
        completion-category-overrides '((file (styles basic-remote orderless))
                                        ;; enable initialism by default for symbols
                                        (command (styles +orderless-with-initialism))
                                        (variable (styles +orderless-with-initialism))
                                        (symbol (styles +orderless-with-initialism))
                                        (elgot (styles +orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
        orderless-style-dispatchers '(+orderless-dispatch)))

(use-package marginalia
  :hook (+my/first-input . marginalia-mode)
  :config
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light)))

(use-package vertico-posframe
  :hook (vertico-mode . vertico-posframe-mode)
  :init
  ;;  BUG: weird behavior on the first time
  (setq vertico-posframe-parameters
        '((min-width . 80)
          (min-height . 15)
          (left-fringe . 8)
          (right-fringe . 8)))
  )

(use-package all-the-icons-completion
  :straight (:host github :repo "iyefrat/all-the-icons-completion")
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))
#+end_src
** Code Completion
#+begin_src emacs-lisp
(use-package corfu
  :straight (corfu :includes (corfu-indexed corfu-quick corfu-popupinfo corfu-history) :files (:defaults "extensions/corfu-*.el"))
  ;; :hook (+my/first-input . global-corfu-mode)
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-auto-prefix 1)
  (corfu-auto-delay 0.01)
  (corfu-echo-documentation 0.3)
  (corfu-quit-no-match 'separator)        ;; Automatically quit if there is no match
  (corfu-on-exact-match 'quit)
  (corfu-preselect 'prompt) ;; Always preselect the prompt
  :init
  (global-corfu-mode)
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("C-n" . corfu-next)
        ("C-j" . corfu-insert)
        ("S-SPC" . corfu-insert-separator)
        ("S-TAB" . corfu-previous)
        ("C-p" . corfu-previous)
        ([?\r] . newline)
        ([backtab] . corfu-previous))
  :config
  (advice-add #'keyboard-quit :before #'corfu-quit)
  (add-to-list 'corfu-auto-commands 'end-of-visual-line)

  ;; https://github.com/minad/corfu/issues/12#issuecomment-869037519
  (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
  (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
  (evil-make-overriding-map corfu-map)

  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input))
      ;; (setq-local corfu-auto nil) Enable/disable auto completion
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)

  (use-package corfu-quick
    :bind
    (:map corfu-map
          ("C-q" . corfu-quick-insert)))

  (use-package corfu-popupinfo
    :config
    (setq corfu-popupinfo-delay '(0.2 . 0.1))
    (set-face-attribute 'corfu-popupinfo nil :height 140)
    :hook (corfu-mode . corfu-popupinfo-mode))

  (use-package corfu-history
    :hook (corfu-mode . corfu-history-mode))

  ;; kind ui
  (with-eval-after-load 'all-the-icons
    (defvar kind-all-the-icons--cache nil
      "The cache of styled and padded label (text or icon).
An alist.")

    (defun kind-all-the-icons-reset-cache ()
      "Remove all cached icons from `kind-all-the-icons-mapping'."
      (interactive)
      (setq kind-all-the-icons--cache nil))

    (defun kind-all-the-icons--set-default-clear-cache (&rest args)
      (kind-all-the-icons-reset-cache)
      (apply #'set-default args))

    (defvar kind-all-the-icons--icons
      `((unknown . ,(all-the-icons-material "find_in_page" :height 0.8 :v-adjust -0.15))
        (text . ,(all-the-icons-faicon "text-width" :height 0.8 :v-adjust -0.02))
        (method . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
        (function . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
        (fun . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
        (constructor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
        (ctor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
        (field . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
        (variable . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
        (var . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
        (class . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
        (interface . ,(all-the-icons-material "share" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
        (i/f . ,(all-the-icons-material "share" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
        (module . ,(all-the-icons-material "view_module" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
        (mod . ,(all-the-icons-material "view_module" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
        (property . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.02))
        (prop . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.02))
        (unit . ,(all-the-icons-material "settings_system_daydream" :height 0.8 :v-adjust -0.15))
        (value . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
        (enum . ,(all-the-icons-material "storage" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
        (keyword . ,(all-the-icons-material "filter_center_focus" :height 0.8 :v-adjust -0.15))
        (k/w . ,(all-the-icons-material "filter_center_focus" :height 0.8 :v-adjust -0.15))
        (snippet . ,(all-the-icons-material "format_align_center" :height 0.8 :v-adjust -0.15))
        (sn . ,(all-the-icons-material "format_align_center" :height 0.8 :v-adjust -0.15))
        (color . ,(all-the-icons-material "palette" :height 0.8 :v-adjust -0.15))
        (file . ,(all-the-icons-faicon "file-o" :height 0.8 :v-adjust -0.02))
        (reference . ,(all-the-icons-material "collections_bookmark" :height 0.8 :v-adjust -0.15))
        (ref . ,(all-the-icons-material "collections_bookmark" :height 0.8 :v-adjust -0.15))
        (folder . ,(all-the-icons-faicon "folder-open" :height 0.8 :v-adjust -0.02))
        (dir . ,(all-the-icons-faicon "folder-open" :height 0.8 :v-adjust -0.02))
        (enum-member . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
        (enummember . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
        (member . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
        (constant . ,(all-the-icons-faicon "square-o" :height 0.8 :v-adjust -0.1))
        (const . ,(all-the-icons-faicon "square-o" :height 0.8 :v-adjust -0.1))
        (struct . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
        (event . ,(all-the-icons-octicon "zap" :height 0.8 :v-adjust 0 :face 'all-the-icons-orange))
        (operator . ,(all-the-icons-material "control_point" :height 0.8 :v-adjust -0.15))
        (op . ,(all-the-icons-material "control_point" :height 0.8 :v-adjust -0.15))
        (type-parameter . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.02))
        (param . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.02))
        (template . ,(all-the-icons-material "format_align_left" :height 0.8 :v-adjust -0.15))
        (tmux . ,(all-the-icons-alltheicon "terminal-alt" :height 0.8 :v-adjust 0))
        (tabnine . ,(all-the-icons-material "cloud" :height 0.8))
        (t . ,(all-the-icons-material "find_in_page" :height 0.8 :v-adjust -0.15))))


    (defsubst kind-all-the-icons--metadata-get (metadata type-name)
      (or
       (plist-get completion-extra-properties (intern (format ":%s" type-name)))
       (cdr (assq (intern type-name) metadata))))

    (defun kind-all-the-icons-formatted (kind)
      "Format icon kind with all-the-icons"
      (or (alist-get kind kind-all-the-icons--cache)
          (let ((map (assq kind kind-all-the-icons--icons)))
            (let*  ((icon (if map
                              (cdr map)
                            (cdr (assq t kind-all-the-icons--icons))))
                    (half (/ (default-font-width) 2))
                    (pad (propertize " " 'display `(space :width (,half))))
                    (disp (concat pad icon pad)))
              (setf (alist-get kind kind-all-the-icons--cache) disp)
              disp))))

    (defun kind-all-the-icons-margin-formatter (metadata)
      "Return a margin-formatter function which produces kind icons.
METADATA is the completion metadata supplied by the caller (see
info node `(elisp)Programmed Completion').  To use, add this
function to the relevant margin-formatters list."
      (if-let ((kind-func (kind-all-the-icons--metadata-get metadata "company-kind")))
          (lambda (cand)
	        (if-let ((kind (funcall kind-func cand)))
	            (kind-all-the-icons-formatted kind)
	          (kind-all-the-icons-formatted t))))) ;; as a backup
    (add-to-list 'corfu-margin-formatters #'kind-all-the-icons-margin-formatter))


  ;; allow evil-repeat
  ;; https://github.com/minad/corfu/pull/225
  (defun corfu--unread-this-command-keys ()
    (when (> (length (this-command-keys)) 0)
      (setq unread-command-events (nconc
                                   (listify-key-sequence (this-command-keys))
                                   unread-command-events))
      (clear-this-command-keys t)))

  (defun corfu--pre-command ()
    "Insert selected candidate unless command is marked to continue completion."
    (when corfu--preview-ov
      (delete-overlay corfu--preview-ov)
      (setq corfu--preview-ov nil))
    ;; Ensure that state is initialized before next Corfu command
    (when (and (symbolp this-command) (string-prefix-p "corfu-" (symbol-name this-command)))
      (corfu--update))
    (when (and (eq corfu-preview-current 'insert)
               (/= corfu--index corfu--preselect)
               ;; See the comment about `overriding-local-map' in `corfu--post-command'.
               (not (or overriding-terminal-local-map
                        (corfu--match-symbol-p corfu-continue-commands this-command))))
      (corfu--unread-this-command-keys)
      (setq this-command 'corfu-insert-exact)))

  (defun corfu-insert-exact ()
    "Insert current candidate with the `exact' status.
Quit if no candidate is selected."
    (interactive)
    (if (>= corfu--index 0)
        (corfu--insert 'exact)
      (corfu-quit)))

  (mapc #'evil-declare-ignore-repeat
        '(corfu-next
          corfu-previous
          corfu-first
          corfu-last))

  (mapc #'evil-declare-change-repeat
        '(corfu-insert
          corfu-insert-exact
          corfu-complete))
  )

(use-package emacs
  :init
  (setq completion-cycle-threshold 3)
  (setq tab-always-indent 'completion))

(use-package tempel
  :after corfu
  :after-call +my/first-input-hook-fun
  :straight (:host github :repo "minad/tempel")
  :config
  (defun my/tempel-expand-or-next ()
    "Try tempel expand, if failed, try copilot expand."
    (interactive)
    (if tempel--active
        (tempel-next 1)
      (call-interactively #'tempel-expand)))
  (with-eval-after-load 'general
    (general-define-key
     :keymaps '(evil-insert-state-map)
     "C-k" 'my/tempel-expand-or-next)))

(use-package cape
  :after (corfu tempel)
  :bind (("C-x C-f" . cape-file)
         ("C-x C-l" . cape-line))
  :hook ((prog-mode . my/set-basic-capf)
         (org-mode . my/set-basic-capf)
         ((lsp-completion-mode eglot-managed-mode lsp-bridge-mode lspce-mode). my/set-lsp-capf))
  :config

  ;;  TODO: Not test whether it works
  (defun cape--limited-table (table)
    (lambda (prefix pred action)
      (if (eq action t)
          (let ((count 0) result)
            (catch 'cape--limit
              (all-completions prefix table
                               (lambda (cand)
                                 (when (or (not pred) (funcall pred cand))
                                   (if (> count 100)
                                       (throw 'cape--limit t)
                                     (cl-incf count)
                                     (when (symbolp cand)
                                       (setq cand (symbol-name cand)))
                                     (push cand result)))
                                 nil)))
            result)
        (complete-with-action action table prefix pred))))


  (defun cape-wrap-limited (capf)
    (pcase (funcall capf)
      (`(,beg ,end ,table . ,plist)
       `(,beg ,end ,(cape--limited-table table) ,@plist))))

  (cape--capf-wrapper limited)


  (setq dabbrev-upcase-means-case-search t)
  (setq case-fold-search nil)
  (defun my/convert-super-capf (arg-capf)
    (list
     #'cape-file
     ;; (cape-capf-buster
     (cape-super-capf
      arg-capf
      #'tabnine-capf)
     ;; 'equal)
     #'tmux-capf
     ;; #'cape-dabbrev
     #'eng-capf
     ))

  (defun my/set-basic-capf ()
    (setq completion-category-defaults nil)
    (setq-local completion-at-point-functions (my/convert-super-capf (cape-capf-limited (car (last completion-at-point-functions 2))))))

  (defun my/set-lsp-capf ()
    (setq completion-category-defaults nil)
    (setq-local completion-at-point-functions (my/convert-super-capf
                                               'lsp-capf))
    (when (derived-mode-p 'latex-mode) ;;  HACK: reftex not working in latex-mode
      (add-to-list 'completion-at-point-functions #'+my/reftex-citation-completion)))

  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))

(use-package corfu-english-helper
  :after cape
  ;; :bind (("C-x C-e" . corfu-english-helper-search))
  :bind (("C-x C-e" . eng-capf))
  :commands (corfu-english-helper-search)
  :defer t
  :straight (:host github :repo "manateelazycat/corfu-english-helper")
  :config
  (fset 'eng-capf (cape-interactive-capf (cape-capf-limited #'corfu-english-helper-search)))
  )

(use-package tabnine-capf
  :after cape
  :commands (tabnine-capf tabnine-capf-start-process)
  :straight (:host github :repo "50ways2sayhard/tabnine-capf" :files ("*.el" "*.sh" "*.py"))
  :hook ((kill-emacs . tabnine-capf-kill-process))
  :config
  (defalias 'tabnine-capf 'tabnine-completion-at-point))

(use-package tmux-capf
  :straight (:host github :repo "theFool32/tmux-capf" :files ("*.el" "*.sh"))
  :after cape
  :commands tmux-capf)
#+end_src
* Utils
#+begin_src emacs-lisp
(use-package recentf
  :hook (after-init . recentf-mode)
  :custom
  ;; (recentf-auto-cleanup "05:00am")
  (recentf-max-saved-items 200)
  (recentf-exclude `(,(expand-file-name package-user-dir)
                     ,+self/org-base-dir
                     ,(expand-file-name "~\/.mail\/*")
                     ;; "^/\\(?:ssh\\|scp\\|su\\|sudo\\)?:"
                     ".cache"
                     ".cask"
                     ".elfeed"
                     "bookmarks"
                     "cache"
                     "ido.*"
                     "persp-confs"
                     "recentf"
                     "undo-tree-hist"
                     "url"
                     "COMMIT_EDITMSG\\'"))
  :config
  (defun recentd-track-opened-file ()
    "Insert the name of the directory just opened into the recent list."
    (and (derived-mode-p 'dired-mode) default-directory
         (recentf-add-file default-directory))
    ;; Must return nil because it is run from `write-file-functions'.
    nil)

  (defun recentd-track-closed-file ()
    "Update the recent list when a dired buffer is killed.
That is, remove a non kept dired from the recent list."
    (and (derived-mode-p 'dired-mode) default-directory
         (recentf-remove-if-non-kept default-directory)))

  (add-hook 'dired-after-readin-hook 'recentd-track-opened-file)
  (add-hook 'kill-buffer-hook 'recentd-track-closed-file)

  (defun recentf-keep-tramp-predicate (file)
    "Return non-nil if FILE should be kept in the recent list.
It handles the case of remote files as well."
    (cond
     ((file-remote-p file))
     ((file-readable-p file))))
  (custom-set-variables '(recentf-keep '(recentf-keep-tramp-predicate)))

  (defun do-recentf-cleanup ()
    "Clean up not existed files for recentf"
    (interactive)
    (let ((recentf-keep '(recentf-keep-default-predicate)))
      (recentf-cleanup)))
  )

(use-package sudo-edit
  :commands (sudo-edit))

(use-package gcmh
  :hook (emacs-startup . gcmh-mode)
  :init
  (setq gcmh-idle-delay 'auto
        gcmh-auto-idle-delay-factor 10
        gcmh-high-cons-threshold (* 64 1024 1024)))

(use-package restart-emacs
  :commands restart-emacs)

(use-package atomic-chrome
  :defer
  :commands (atomic-chrome-start-server)
  :config
  (setq atomic-chrome-url-major-mode-alist
	    '(("overleaf\\.com" . LaTeX-mode))))

(use-package tramp
  :defer 1
  :straight nil
  :config
  (setq tramp-completion-use-auth-sources nil
        tramp-verbose 0
        tramp-chunksize 2000
        tramp-use-ssh-controlmaster-options nil)
  (setq remote-file-name-inhibit-cache nil
        vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp)))

(use-package vundo
  :straight (:host github :repo "casouri/vundo")
  :commands vundo
  :defer t
  :config
  (setf (alist-get 'selected-node vundo-glyph-alist) ?X
        (alist-get 'node vundo-glyph-alist) ?O))

(use-package super-save

  :defer 0.5
  :init
  (setq auto-save-default nil)
  :config
  (add-to-list 'super-save-triggers 'switch-window)
  (add-to-list 'super-save-triggers 'switch-to-buffer)
  (setq super-save-exclude '(".gpg"))
  (setq super-save-idle-duration 3)
  (setq save-silently t)
  (setq super-save-auto-save-when-idle t)
  (super-save-mode 1)
  (advice-add 'super-save-command :override 'save-all-buffers))

(use-package ztree
  :commands ztree-diff)

(use-package winner
  :ensure nil
  :commands (winner-undo winner-redo)
  :hook (after-init . winner-mode)
  :init (setq winner-boring-buffers '("*Completions*"
                                      "*Compile-Log*"
                                      "*inferior-lisp*"
                                      "*Fuzzy Completions*"
                                      "*Apropos*"
                                      "*Help*"
                                      "*cvs*"
                                      "*Buffer List*"
                                      "*Ibuffer*"
                                      "*esh command on file*")))

(use-package tab-bar
  :ensure nil
  :commands (tab-new tab-bar-rename-tab tab-bar-close-tab tab-bar-select-tab-by-name)
  ;; :hook (after-init . tab-bar-mode)
  :config
  (setq tab-bar-show nil))

(use-package ace-window
  :commands ace-window
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 400)
  )
#+end_src
** Persp
#+begin_src emacs-lisp
(use-package persp-mode

  :defines (recentf-exclude)
  :commands (get-current-persp persp-contain-buffer-p)
  :hook (+my/first-input . persp-mode)
  :init
  (setq persp-keymap-prefix (kbd "C-x p")
        persp-nil-name "default"
        persp-set-last-persp-for-new-frames nil
        persp-kill-foreign-buffer-behaviour 'kill
        persp-auto-resume-time -0.1
        )
  (defun +my/persp-resume ()
    "Resume previous layout"
    (interactive)
    (persp-mode +1)
    (condition-case error
        (persp-load-state-from-file (expand-file-name "persp-auto-save" persp-save-dir))
      (error)))
  :config
  ;; Don't save dead or temporary buffers
  (add-hook 'persp-filter-save-buffers-functions
            (lambda (b)
              "Ignore dead and unneeded buffers."
              (or (not (buffer-live-p b))
                  (string-prefix-p " *" (buffer-name b)))))
  (add-hook 'persp-filter-save-buffers-functions
            (lambda (b)
              "Ignore temporary buffers."
              (let ((bname (file-name-nondirectory (buffer-name b))))
                (or (string-prefix-p "magit" bname)
                    (string-prefix-p "COMMIT_EDITMSG" bname)
                    (string-prefix-p "\*Minibuf-." bname)
                    (string-prefix-p "\*scratch\*" bname)
                    (string-match-p "\\.elc\\|\\.tar\\|\\.gz\\|\\.zip\\'" bname)
                    (string-match-p "\\.bin\\|\\.so\\|\\.dll\\|\\.exe\\'" bname)))))

  ;; Don't save persp configs in `recentf'
  (with-eval-after-load 'recentf
    (push persp-save-dir recentf-exclude))

  (advice-add #'persp-save-state-to-file :before
              (lambda (&optional _)
                (set-persp-parameter
                 'tab-bar-tabs
                 (frameset-filter-tabs (tab-bar-tabs) nil nil t))))

  (advice-add #'persp-load-state-from-file :after
              (lambda (&optional _)
                (tab-bar-tabs-set (persp-parameter 'tab-bar-tabs))
                (tab-bar--update-tab-bar-lines t)))
  )
#+end_src
* Tools
** Dired
#+begin_src emacs-lisp
;; DiredPackage
(use-package dired
  :after-call +my/first-input-hook-fun
  :straight nil
  :bind
  (:map dired-mode-map
        ("C-q" . evil-avy-goto-line))
  :custom
  ;; Always delete and copy recursively
  (dired-recursive-deletes 'always)
  (dired-recursive-copies 'always)
  ;; Auto refresh Dired, but be quiet about it
  (global-auto-revert-non-file-buffers t)
  (auto-revert-verbose nil)
  ;; Quickly copy/move file in Dired
  (dired-dwim-target t)
  ;; Move files to trash when deleting
  (delete-by-moving-to-trash t)
  ;; Load the newest version of a file
  (load-prefer-newer t)
  ;; Detect external file changes and auto refresh file
  (auto-revert-use-notify nil)
  :config
  (setq insert-directory-program "gls" dired-use-ls-dired t)
  (setq dired-listing-switches "-al --group-directories-first")
  ;; Enable global auto-revert
  ;; Reuse same dired buffer, to prevent numerous buffers while navigating in dired
  (put 'dired-find-alternate-file 'disabled nil)

  (with-eval-after-load 'general
    (general-define-key :states '(normal)
                        :keymaps 'dired-mode-map
                        "'" '+my/quick-look
                        "l" 'dired-find-alternate-file
                        "h" 'dired-up-directory)
    )
  )

;; Colourful dired
(use-package diredfl
  :hook (dired-mode . diredfl-mode))

;; Extra Dired functionality
(use-package dired-x
  :straight nil
  :after dired
  :config
  (setq dired-omit-files
        (concat dired-omit-files
                "\\|^.DS_Store$\\|^.projectile$\\|^.git*\\|^.svn$\\|^.vscode$\\|\\.js\\.meta$\\|\\.meta$\\|\\.elc$\\|^.emacs.*"))
  )

(use-package dirvish  ;; `(' for details.
  :straight (dirvish :type git :host github :repo "alexluigit/dirvish")
  :hook ((+my/first-input . dirvish-override-dired-mode)
         (evil-collection-setup . (lambda (&rest a)
                                    (evil-define-key '(normal) dired-mode-map
                                      (kbd "C-c f") 'dirvish-fd
                                      "i" 'wdired-change-to-wdired-mode
                                      "q" 'dirvish-quit
                                      "." 'dired-omit-mode
                                      "s" 'dirvish-narrow ;;use `revert-buffer' (gr) to restore
                                      (kbd "TAB") 'dirvish-subtree-toggle
                                      (kbd "M-s") 'dirvish-setup-menu
                                      (kbd "M-t") 'dirvish-layout-toggle
                                      (kbd "M-f") 'dirvish-toggle-fullscreen
                                      "*"   'dirvish-mark-menu
                                      "f"   'dirvish-file-info-menu
                                      [remap dired-sort-toggle-or-edit] 'dirvish-quicksort
                                      [remap dired-do-redisplay] 'dirvish-ls-switches-menu
                                      [remap dired-summary] 'dirvish-dispatch
                                      [remap dired-do-copy] 'dirvish-yank-menu
                                      [remap mode-line-other-buffer] 'dirvish-history-last))))
  :after dired

  :custom
  (dirvish-mode-line-format ; it's ok to place string inside
   '(:left (sort file-time " " file-size symlink) :right (omit yank index)))
  (dirvish-attributes '(all-the-icons file-size vc-state git-msg))
  (dirvish-side-follow-buffer-file t)
  ;; (dirvish-enabled-features-on-remote '(extras vc))
  :config
  (set-face-attribute 'ansi-color-blue nil :foreground "#FFFFFF")
  (setq dirvish-open-with-programs
        '((("doc" "docx" "odt" "ods" "xls" "rtf" "xlsx" "odp" "ppt" "pptx" "pdf") . ("open" "%f"))))
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches
        "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group")

  (use-package dirvish-extras
    :straight nil
    ))


;; SaveAllBuffers
;;;###autoload
(defun save-all-buffers ()
  "Instead of `save-buffer', save all opened buffers by calling `save-some-bffers' with ARG t."
  (interactive)
  (save-some-buffers t))
(with-eval-after-load 'general
  (general-def "C-x C-s" nil)
  (general-def "C-x C-s" 'save-all-buffers))
;; -SaveAllBuffers
#+end_src
** Magit
#+begin_src emacs-lisp
;; MagitPac
(use-package magit
  :defer t
  :commands (magit magit-open-repo)
  :if *git*
  :config
  ;; (global-auto-revert-mode -1)
  ;; (magit-auto-revert-mode -1)
  (defvar +magit-open-windows-in-direction 'right
    "What direction to open new windows from the status buffer.
For example, diffs and log buffers. Accepts `left', `right', `up', and `down'.")
  (defun +magit-display-buffer-fn (buffer)
    "Same as `magit-display-buffer-traditional', except...
- If opened from a commit window, it will open below it.
- Magit process windows are always opened in small windows below the current.
- Everything else will reuse the same window."
    (let ((buffer-mode (buffer-local-value 'major-mode buffer)))
      (display-buffer
       buffer (cond
               ((and (eq buffer-mode 'magit-status-mode)
                     (get-buffer-window buffer))
                '(display-buffer-reuse-window))
               ;; Any magit buffers opened from a commit window should open below
               ;; it. Also open magit process windows below.
               ((or (bound-and-true-p git-commit-mode)
                    (eq buffer-mode 'magit-process-mode))
                (let ((size (if (eq buffer-mode 'magit-process-mode)
                                0.35
                              0.7)))
                  `(display-buffer-below-selected
                    . ((window-height . ,(truncate (* (window-height) size)))))))

               ;; Everything else should reuse the current window.
               ((or (not (derived-mode-p 'magit-mode))
                    (not (memq (with-current-buffer buffer major-mode)
                               '(magit-process-mode
                                 magit-revision-mode
                                 magit-diff-mode
                                 magit-stash-mode
                                 magit-status-mode))))
                '(display-buffer-same-window))

               ('(+magit--display-buffer-in-direction))))))

  (defun +magit--display-buffer-in-direction (buffer alist)
    "`display-buffer-alist' handler that opens BUFFER in a direction.
This differs from `display-buffer-in-direction' in one way: it will try to use a
window that already exists in that direction. It will split otherwise."
    (let ((direction (or (alist-get 'direction alist)
                         +magit-open-windows-in-direction))
          (origin-window (selected-window)))
      (if-let (window (window-in-direction direction))
          (unless magit-display-buffer-noselect
            (select-window window))
        (if-let (window (and (not (one-window-p))
                             (window-in-direction
                              (pcase direction
                                (`right 'left)
                                (`left 'right)
                                ((or `up `above) 'down)
                                ((or `down `below) 'up)))))
            (unless magit-display-buffer-noselect
              (select-window window))
          (let ((window (split-window nil nil direction)))
            (when (and (not magit-display-buffer-noselect)
                       (memq direction '(right down below)))
              (select-window window))
            (display-buffer-record-window 'reuse window buffer)
            (set-window-buffer window buffer)
            (set-window-parameter window 'quit-restore (list 'window 'window origin-window buffer))
            (set-window-prev-buffers window nil))))
      (unless magit-display-buffer-noselect
        (switch-to-buffer buffer t t)
        (selected-window))))

;;;###autoload
  (defun +magit/quit (&optional kill-buffer)
    "Bury the current magit buffer.

If KILL-BUFFER, kill this buffer instead of burying it.
If the buried/killed magit buffer was the last magit buffer open for this repo,
kill all magit buffers for this repo."
    (interactive "P")
    (let ((topdir (magit-toplevel)))
      (funcall magit-bury-buffer-function kill-buffer)
      (or (cl-find-if (lambda (win)
                        (with-selected-window win
                          (and (derived-mode-p 'magit-mode)
                               (equal magit--default-directory topdir))))
                      (window-list))
          (+magit/quit-all))))

;;;###autoload
  (defun +magit/quit-all ()
    "Kill all magit buffers for the current repository."
    (interactive)
    (mapc #'+magit--kill-buffer (magit-mode-get-buffers)))

  (defun +magit--kill-buffer (buf)
    "TODO"
    (when (and (bufferp buf) (buffer-live-p buf))
      (let ((process (get-buffer-process buf)))
        (if (not (processp process))
            (kill-buffer buf)
          (with-current-buffer buf
            (if (process-live-p process)
                (run-with-timer 5 nil #'+magit--kill-buffer buf)
              (kill-process process)
              (kill-buffer buf)))))))
  (setq magit-display-buffer-function #'+magit-display-buffer-fn)
  (setq magit-diff-refine-hunk (quote all))

  (general-define-key :states '(normal)
                      :keymaps 'magit-mode-map
                      "q" #'+magit/quit
                      "Q" #'+magit/quit-all)


  (defun magit-open-repo ()
    "open remote repo URL"
    (interactive)
    (let ((url (magit-get "remote" "origin" "url")))
      (progn
        (browse-url (if (string-match "^http" url)
                        url
                      (replace-regexp-in-string "\\(.*\\)@\\(.*\\):\\(.*\\)\\(\\.git?\\)"
                                                "https://\\2/\\3"
                                                url)))
        (message "opening repo %s" url))))

  (defun aborn/simple-git-commit-push ()
    "Simple commit current git project and push to its upstream."
    (interactive)
    (when (and buffer-file-name (buffer-modified-p))
      (save-buffer))
    (magit-stage-modified)
    (magit-diff-staged)
    (setq msg (read-string "Commit Message: "))
    (when (length= msg 0)
      (setq msg (format-time-string "commit by magit in emacs@%Y-%m-%d %H:%M:%S"
                                    (current-time))))
    (magit-call-git "commit" "-m" msg)
    (when (magit-get "remote" "origin" "url")
      (magit-push-current-to-upstream nil)
      (message "now do async push to %s" (magit-get "remote" "origin" "url")))
    (magit-mode-bury-buffer))
  )
;; -MagitPac

(use-package magit-todos
  :after magit
  :init
  ;; HACK
  (defun magit--tramp-asserts (dir)
    "override `magit--tramp-asserts'"
    nil))

;; Walk through git revisions of a file
(use-package git-timemachine
  :straight (:host codeberg :repo "pidu/git-timemachine")
  :after magit
  :custom-face
  (git-timemachine-minibuffer-author-face ((t (:inherit success))))
  (git-timemachine-minibuffer-detail-face ((t (:inherit warning))))
  :bind (:map vc-prefix-map
              ("t" . git-timemachine))
  :hook (before-revert . (lambda ()
                           (when (bound-and-true-p git-timemachine-mode)
                             (user-error "Cannot revert the timemachine buffer"))))
  :config
  (with-eval-after-load 'evil
    (add-hook 'git-timemachine-mode-hook #'evil-normalize-keymaps)))

(use-package magit-gitflow
  :after magit
  :hook (magit-mode . turn-on-magit-gitflow)
  :bind (:map magit-status-mode-map
              ("%" . magit-gitflow-popup)))

(use-package smerge-mode
  :straight nil
  :commands smerge-mode
  :hook ((find-file . (lambda ()
                        (save-excursion
                          (goto-char (point-min))
                          (when (re-search-forward "^<<<<<<< " nil t)
                            (smerge-mode 1)))))
         (smerge-mode . evil-normalize-keymaps))
  :config
  (local-leader-def
    :keymaps 'smerge-mode-map
    "n" '(smerge-next :wk "Next conflict")
    "p" '(smerge-prev :wk "Previous conflict")
    "RET" '(smerge-keep-current :wk "Accept current")
    "l" '(smerge-keep-lower :wk "Keep lower")
    "u" '(smerge-keep-upper :wk "Keep upper")
    "m" '(smerge-keep-mine :wk "Keep mine")
    "A" '(smerge-keep-all :wk "Keep all")))

(defvar gitmoji--all-emoji
  '(("增加新特性" . "feat:")
    ("bug 修复" . "fix:")
    ("文档改动" . "docs:")
    ("功能、交互优化" . "improve:")
    ("格式改动（不影响代码运行的变动，例如加空格、换行、分号等）" . "style:")
    ("重构代码" . "refactor:")
    ("性能相关优化" . "perf:")
    ("测试代码" . "test:")
    ("构建过程或辅助工具变动" . "chore:")
    ("回滚" . "revert:")
    ("合并" . "merge:")
    ("上传资源文件" . "resource:")))

(defun gitmoji-picker ()
  "Choose a gitmoji."
  (interactive)
  (let* ((choices gitmoji--all-emoji)
         (candidates (mapcar (lambda (cell)
                               (cons (format "%s — %s" (cdr cell) (car cell)) (concat (cdr cell) " ")))
                             choices)))
    (insert (cdr (assoc (completing-read "Choose a gitmoji " candidates) candidates)))
    (evil-insert-state)))

(use-package blamer
  :straight (:host github :repo "artawower/blamer.el")
  :bind (("s-i" . blamer-show-posframe-commit-info))
  :commands (blamer-show-posframe-commit-info)
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                    :background unspecified
                    :height 140
                    :italic t))))
#+end_src
** Checker
#+begin_src emacs-lisp
;; flymake
(use-package flymake
  :ensure nil
  :hook ((prog-mode markdown-mode LaTeX-mode) . flymake-mode)
  :config
  (setq flymake-no-changes-timeout nil)
  ;; (setq-local flymake-diagnostic-functions nil)
  (setq flymake-fringe-indicator-position 'right-fringe)
  (use-package flymake-posframe
    :straight (:host github :repo "articuluxe/flymake-posframe" :branch "feature/eglot")
    :hook (flymake-mode . flymake-posframe-mode))
  ;;  TODO: use `flymake-flycheck' or `flymake-collection' to enhance backends
  )

(use-package wucuo
  :hook (LaTeX-mode . wucuo-mode)
  :config
  (setq ispell-program-name "aspell")
  ;; You could add extra option "--camel-case" for since Aspell 0.60.8
  ;; @see https://github.com/redguardtoo/emacs.d/issues/796
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--run-together"))
  (add-hook 'text-mode-hook #'wucuo-start)
  (general-define-key :states 'normal
                      :keymaps 'LaTeX-mode-map
                      :prefix ","
                      "g" '(flyspell-auto-correct-word :wk "Auto correct")
                      "d" '(flyspell-correct-word-before-point :wk "Correct word")))
#+end_src
** Ebib
#+begin_src emacs-lisp
(use-package ebib
  :commands ebib
  :straight (ebib :includes (org-ebib) :host github :repo "theFool32/ebib")
  :hook (ebib-index-mode . hl-line-mode)
  :custom
  (ebib-file-associations '(("pdf" . "open")))
  (ebib-index-window-size 30)
  (ebib-citation-description-function 'ebib-title-description)
  (ebib-preload-bib-files (list (concat +self/ebib-base-dir "ref.bib")))
  (ebib-file-search-dirs (list (concat +self/ebib-base-dir "pdfs/")))
  (ebib-notes-directory (concat +self/ebib-base-dir "notes/"))
  (ebib-keywords (concat +self/ebib-base-dir "ebib-keywords.txt"))
  (ebib-keywords-field-keep-sorted t)
  (ebib-keywords-save-on-exit 'always)
  (ebib-filters-default-file (concat +self/ebib-base-dir "ebib-filters"))
  (ebib-timestamp-format "%Y-%m-%d,%T")
  (ebib-index-default-sort '("timestamp" . descend))
  (ebib-use-timestamp t "recording the time that entries are added")
  (ebib-extra-fields
   '((BibTeX "keywords" "abstract" "timestamp" "read"
             "file"  "url" "crossref" "annote" "doi")))
  (ebib-hidden-fields
   '("volume" "number" "series" "editor" "pages" "address" "month" "organization" "publisher" "crossref"))
  (ebib-index-columns '(("Title" 70 t)
                        ("Author/Editor" 33 t)
                        ("Year" 4 t)
                        ("timestamp" 19 t)
                        ("read" 1 t)
                        ("readtime" 19 t)))
  :bind
  (:map ebib-index-mode-map
        ("/" . ebib-jump-to-entry)
        ("?" . ebib-swiper)
        ;; ("?" . ebib-search)
        ("D" . ebib-delete-entry-with-file)
        ("s"   . ebib-save-all-databases)
        ("S"   . +my/search-pdf)
        ("B"   . ebib-import-ref)
        :map ebib-multiline-mode-map
        ("C-c C-c" . ebib-quit-multiline-buffer-and-save)
        ("C-c C-q" . ebib-cancel-multiline-buffer)
        ("C-c C-s" . ebib-save-from-multiline-buffer)
        :map bibtex-mode-map
        ("C-c C-i" . insert-to-bib))
  :init
  (defun ebib-swiper ()
    (interactive)
    (progn (consult-line) (ebib--update-entry-buffer)))

  ;;  TODO: search only the current pdf
  ;;  TODO: split the files and the contents
  (defun +my/search-pdf ()
    (interactive)
    (consult-ripgrep (concat +self/ebib-base-dir "/pdfs") ""))

  (random t)
  (defun get-random-uuid ()
    "Insert a random UUID.
Example of a UUID: 1df63142-a513-c850-31a3-535fc3520c3d

WARNING: this is a simple implementation.  The chance of generating the same UUID is much higher than a robust algorithm.."
    (interactive)

    (format "%04x%04x-%04x-%04x-%04x-%06x%06x"
            (random (expt 16 4))
            (random (expt 16 4))
            (random (expt 16 4))
            (random (expt 16 4))
            (random (expt 16 4))
            (random (expt 16 6))
            (random (expt 16 6))))


  (defun my-ebib--format-entry (key db &optional timestamp sort)
    "Write entry KEY in DB into the current buffer in BibTeX format.
If TIMESTAMP is non-nil and `ebib-use-timestamp' is set, a
timestamp is added to the entry, possibly overwriting an existing
timestamp.  If SORT is non-nil, the fields are sorted before
formatting the entry."
    (let* ((entry (copy-alist (ebib-db-get-entry key db 'noerror)))
           (type (cdr (assoc "=type=" entry)))
           (my-needed-fields '("author" "booktitle" "year" "title" "journal")))
      (when entry
        (if (and timestamp ebib-use-timestamp)
            (setcdr (assoc-string "timestamp" entry 'case-fold) (format-time-string (concat "{" ebib-timestamp-format "}"))))
        (setq entry (seq-filter (lambda (field)
                                  (and (cdr field) ; Remove fields with value nil. See `ebib-set-field-value'.
                                       (not (ebib--special-field-p (car field))))
                                  (member (car field) my-needed-fields))
                                entry))
        (setq entry (if sort
                        (cl-sort entry #'string< :key #'car)
                      ;; When reading, fields are stored with `push', so if we don't
                      ;; sort, we need to reverse them to get the original order
                      ;; back.  See github issues #42, #55, #62.
                      (reverse entry)))
        (insert (format "@%s{%s,\n" type key))
        (insert (mapconcat (lambda (field)
                             (format "\t%s = %s" (car field) (cdr field)))
                           entry
                           ",\n"))
        (insert "\n}\n\n"))))

  (defun insert-to-bib ()
    (interactive)
    (call-interactively 'ebib-jump-to-entry)
    (ebib--execute-when
     (entries
      (let ((key (ebib--get-key-at-point)))
        (with-temp-buffer
          (my-ebib--format-entry key ebib--cur-db)
          (kill-new (buffer-substring-no-properties (point-min) (point-max))))
        (message (format "Entry `%s' copied to kill ring.  Use `y' to yank (or `C-y' outside Ebib)." key))))
     (default
      (beep)))
    (yank))

  (defun ebib-import-ref (url)
    (interactive "sUrl:")
    (let ((buffername (concat "*ref-" (get-random-uuid) "*"))
          (pdf-url url))
      (run-with-idle-timer
       0.1
       nil
       (lambda ()
         (let ((tempbuff (get-buffer-create buffername)))
           (make-process
            :name ""
            :buffer tempbuff
            :command (list "ref_down.py" pdf-url (concat +self/ebib-base-dir "/pdfs"))
            :sentinel (lambda (process event)
                        ;; Render result to content buffer when subprocess finish.
                        (when (string= (substring event 0 -1) "finished")
                          (let ((buffer (process-buffer process)))
                            ;; Do nothing if process buffer has killed.
                            (when (get-buffer buffer)
                              (with-current-buffer buffer
                                (ebib-import-entries)
                                (kill-buffer buffer)
                                (ebib--update-buffers))))))))))))
  :config
  (use-package org-ebib
    :config
    (local-leader-def
      :keymaps 'org-mode-map
      "lb" 'org-ebib-insert-link)))
#+end_src
** Rime
karabiner: shift for emacs-rime
#+begin_src json
{
    "description": "Shift for Emacs-Rime",
    "manipulators": [
        {
            "type": "basic",
            "from": {
                "key_code": "left_shift",
                "modifiers": {
                    "optional": [
                        "any"
                    ]
                }
            },
            "to": [
                {
                    "key_code": "left_shift",
                    "lazy": true
                }
            ],
            "to_if_alone": [
                {
                    "key_code": "backslash",
                    "modifiers": ["left_control"]
                }
            ],
            "conditions": [
                {
                "type": "frontmost_application_if",
                "bundle_identifiers": ["org\\.gnu\\.Emacs"]
                }
            ]
        }
    ]
},
#+end_src
#+begin_src emacs-lisp
(use-package rime
  :after-call toggle-input-method
  :if +self/use-rime
  :init
  (setq rime-librime-root "~/.emacs.d/librime/dist/"
        rime-user-data-dir "~/.emacs.d/Rime/"
        default-input-method "rime")

  :custom
  (rime-show-candidate 'posframe)
  (rime-posframe-properties (list :font "sarasa ui sc"
                                  :internal-border-width 2))
  :config
  (unless rime-emacs-module-header-root
    (setq rime-emacs-module-header-root "/Applications/Emacs.app/Contents/Resources/include/"))

  (define-key rime-mode-map (kbd "M-j") 'rime-force-enable)
  (define-key rime-mode-map (kbd "M-k") 'rime-inline-ascii)

  (defun rime-predicate-tex-math-p ()
    (and (derived-mode-p 'tex-mode)
         (or (and (featurep 'tex-site)
                  (texmathp))
             (and rime--current-input-key
                  (or (= #x24 rime--current-input-key)
                      (= #x5c rime--current-input-key))
                  (or (= (point) (line-beginning-position))
                      (= #x20 (char-before))
                      (rime-predicate-after-ascii-char-p))))))

  (setq rime-disable-predicates
        '(rime-predicate-evil-mode-p
          rime-predicate-after-alphabet-char-p
          rime-predicate-prog-in-code-p
          rime-predicate-after-ascii-char-p
          rime-predicate-space-after-cc-p
          rime-predicate-tex-math-p))

  )
#+end_src
** Shell
#+begin_src emacs-lisp
(when (and module-file-suffix
           (executable-find "cmake")
           (executable-find "libtool")
           (executable-find "make"))
  (use-package vterm
    :commands (vterm--internal vterm-posframe-toggle +my/smart-switch-to-vterm-tab)
    :init
    (setq vterm-always-compile-module t)
    (setq vterm-shell "tmux")
    (setq vterm-timer-delay 0.001
          process-adaptive-read-buffering nil)
    :config
    (evil-define-key 'insert vterm-mode-map (kbd "C-c") 'vterm-send-C-c)
    (evil-define-key 'normal vterm-mode-map (kbd "<escape>") 'vterm-send-escape)

    (defun +my/smart-switch-to-vterm-tab ()
      "Switch to vterm tab if exists, otherwise create a new vterm tab."
      (interactive)
      (let ((vterm-buffer-name "vterm-tab"))
        (if (get-buffer vterm-buffer-name)
            (progn
              (tab-bar-select-tab-by-name "vterm")
              (switch-to-buffer vterm-buffer-name))
          (tab-new)
          (tab-bar-rename-tab "vterm")
          (call-interactively #'vterm)
          (delete-other-windows))))

    (with-no-warnings
      (defvar vterm-posframe--frame nil)

      (defun vterm-posframe-hidehandler (_)
        "Hidehandler used by `vterm-posframe-toggle'."
        (not (eq (selected-frame) posframe--frame)))

      (defun vterm-posframe-toggle ()
        "Toggle `vterm' child frame."
        (interactive)
        (let* ((vterm-posframe-buffer-name "vterm-posframe")
               (buffer (or (get-buffer vterm-posframe-buffer-name) (vterm--internal #'ignore vterm-posframe-buffer-name)))
               (width  (max 80 (/ (frame-width) 2)))
               (height (/ (frame-height) 2)))
          (if (and vterm-posframe--frame
                   (frame-live-p vterm-posframe--frame)
                   (frame-visible-p vterm-posframe--frame))
              (progn
                (posframe-hide buffer)
                ;; Focus the parent frame
                (select-frame-set-input-focus (frame-parent vterm-posframe--frame)))
            (setq vterm-posframe--frame
                  (posframe-show
                   buffer
                   :poshandler #'posframe-poshandler-frame-center
                   :hidehandler #'vterm-posframe-hidehandler
                   :left-fringe 8
                   :right-fringe 8
                   :width width
                   :height height
                   :min-width width
                   :min-height height
                   :internal-border-width 3
                   :internal-border-color (face-foreground 'font-lock-comment-face nil t)
                   :background-color (face-background 'tooltip nil t)
                   :override-parameters '((cursor-type . 't))
                   :accept-focus t))
            ;; Focus the child frame
            (select-frame-set-input-focus vterm-posframe--frame))))
      )))
#+end_src
** Mail
#+begin_src emacs-lisp
(defvar mu-path (format "%s%s" (getenv "MU_PATH") "/share/emacs/site-lisp/mu/mu4e"))
(use-package mu4e
  :straight nil
  :load-path mu-path
  :if (executable-find "mu")
  :commands mu4e
  :hook ((mu4e-headers-mode . hl-line-mode)
         (mu4e-compose-mode . (lambda ()
                                (electric-indent-local-mode nil))))
  :init
  (provide 'html2text)
  :config
  (setenv "XAPIAN_CJK_NGRAM" "true")

  (setq
   mu4e-change-filenames-when-moving t
   mu4e-hide-index-messages t
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy nil
   mail-user-agent 'mu4e-user-agent
   send-mail-function 'smtpmail-send-it
   message-send-mail-function 'smtpmail-send-it
   smtpmail-smtp-service 587
   smtpmail-starttls-credentials (expand-file-name "~/.authinfo.gpg")
   smtpmail-stream-type  'starttls
   ;; mu4e-get-mail-command "offlineimap"
   mu4e-get-mail-command "true"
   mu4e-update-interval nil
   ;; 回复邮件插入邮件引用信息
   message-citation-line-function 'message-insert-formatted-citation-line
   message-citation-line-format "On %a, %b %d %Y, %f wrote:\n"
   mu4e-view-show-images t
   mu4e-view-image-max-width 800
   mu4e-compose-signature-auto-include t
   mu4e-compose-dont-reply-to-self t
   mu4e-use-fancy-chars nil
   mu4e-headers-include-related t
   mu4e-headers-skip-duplicates t
   mu4e-completing-read-function 'completing-read
   message-kill-buffer-on-exit t
   mu4e-confirm-quit nil
   mu4e-compose-format-flowed t
   mu4e-view-show-addresses t

   ;; 根据 from 邮件头使用正确的账户上下文发送 Email.
   message-sendmail-envelope-from 'header

   mu4e-maildir "~/.mail"

   mu4e-headers-thread-single-orphan-prefix '("─>" . "─▶")
   mu4e-headers-thread-orphan-prefix        '("┬>" . "┬▶ ")
   mu4e-headers-thread-connection-prefix    '("│ " . "│ ")
   mu4e-headers-thread-first-child-prefix   '("├>" . "├▶")
   mu4e-headers-thread-child-prefix         '("├>" . "├▶")
   mu4e-headers-thread-last-child-prefix    '("└>" . "╰▶")
   )

  (setq mu4e-bookmarks
        '( ("flag:unread AND NOT flag:trashed"      "Unread messages"   ?u)
           ("m:/Gmail/Inbox or m:/Outlook/Inbox or m:/XMU/Inbox" "Inbox" ?i)
           ("date:today..now"  "Today's messages"   ?t)
           ("date:7d..now"  "Last 7 days"           ?w)
           ("mime:image/*"  "Messages with images"  ?p)))

  (setq mu4e-headers-fields
        '((:human-date . 12)
          (:flags . 4)
          (:maildir . 25)
          (:from . 22)
          (:subject)))


  ;; 该函数基于当前所在的 maildir 来判定所账户上下文。
  (defun mu4e-message-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
          ;; If rx is a list, try each one for a match
          (or (mu4e-message-maildir-matches msg (car rx))
              (mu4e-message-maildir-matches msg (cdr rx)))
        ;; Not a list, check rx
        (string-match rx (mu4e-message-field msg :maildir)))))

  ;; 中文搜索
  (defun mu4e-goodies~break-cjk-word (word)
    "Break CJK word into list of bi-grams like: 我爱你 -> 我爱 爱你"
    (if (or (<= (length word) 2)
            (equal (length word) (string-bytes word))) ; only ascii chars
        word
      (let ((pos nil)
            (char-list nil)
            (br-word nil))
        (if (setq pos (string-match ":" word))     ; like: "s:abc"
            (concat (substring word 0 (+ 1 pos))
                    (mu4e-goodies~break-cjk-word (substring word (+ 1 pos))))
          (if (memq 'ascii (find-charset-string word)) ; ascii mixed with others like: abc你好
              word
            (progn
              (setq char-list (split-string word "" t))
              (while (cdr char-list)
                (setq br-word (concat br-word (concat (car char-list) (cadr char-list)) " "))
                (setq char-list (cdr char-list)))
              br-word))))))
  (defun mu4e-goodies~break-cjk-query (expr)
    "Break CJK strings into bi-grams in query."
    (let ((word-list (split-string expr " " t))
          (new ""))
      (dolist (word word-list new)
        (setq new (concat new (mu4e-goodies~break-cjk-word word) " ")))))
  (setq mu4e-query-rewrite-function 'mu4e-goodies~break-cjk-query)

  (defun open-mail-in-browser (&optional mail)
    (interactive)
    (let ((mails '(("Gmail". "https://www.gmail.com")
                   ("Outlook" . "https://www.outlook.com")
                   ("XMU" . "https://stu.xmu.edu.cn"))))
      (browse-url
       (cdr (assoc (completing-read "Mail:" (mapcar 'car mails)) mails)))))
  (general-define-key :states '(normal)
                      :keymaps 'mu4e-main-mode-map
                      "o" #'open-mail-in-browser)
  )
#+end_src
** PDF-Tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :hook (dired-mode . pdf-tools-install)
  :config
  ;; (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page)
  (setq pdf-annot-activate-created-annotations t) ; automatically annotate highlights
  (setq pdf-view-resize-factor 1.1) ; more fine-grained zooming
  )
#+end_src
* UI
#+begin_src emacs-lisp
;; SmoothScroll
;; Vertical Scroll
(setq scroll-step 1)
(setq scroll-margin 1)
(setq scroll-conservatively 101)
(setq scroll-up-aggressively 0.01)
(setq scroll-down-aggressively 0.01)
(setq auto-window-vscroll nil)
(setq mouse-wheel-scroll-amount '(2 ((shift) . 1)))
(setq mouse-wheel-progressive-speed t)
;; Horizontal Scroll
(setq hscroll-step 1)
(setq hscroll-margin 1)
;; -SmoothScroll

;; TitleBar
(setq-default frame-title-format '("EMACS" " - %b"))
;; -TitleBar


;; YorN
(fset 'yes-or-no-p 'y-or-n-p)
;; -YorN

(menu-bar-mode 0)

;; DisLineNum
(add-hook 'text-mode-hook #'display-line-numbers-mode)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'org-mode-hook #'(lambda () (display-line-numbers-mode 0)))
;; Display column numbers in modeline
(column-number-mode 1)
(setq display-line-numbers-type 'relative)
;; -DisLineNum

;; DisTimeBat
(setq display-time-format "%m-%d %I:%M"
      display-time-mail-string ""
      display-time-default-load-average nil)
(display-time-mode t)
;; (display-battery-mode 1)
;; -DisTimeBat

;;Font

(when (display-graphic-p)
  ;; (add-to-list 'default-frame-alist '(font . "CaskaydiaCove Nerd Font-14"))
  (set-face-attribute 'default nil
                      :font "CaskaydiaCove Nerd Font"
                      :height 140)
  (set-fontset-font t '(#x4e00 . #x9fff) "Sarasa Mono SC")
  )

(setq split-width-threshold 0
      split-height-threshold nil)

;; ATIPac
(use-package all-the-icons
  :demand t
  :if (display-graphic-p)
  ;; :init (all-the-icons-install-fonts t)
  :config
  (defun all-the-icons-reset ()
    "Reset (unmemoize/memoize) the icons."
    (interactive)
    (dolist (f '(all-the-icons-icon-for-file
                 all-the-icons-icon-for-mode
                 all-the-icons-icon-for-url
                 all-the-icons-icon-family-for-file
                 all-the-icons-icon-family-for-mode
                 all-the-icons-icon-family))
      (ignore-errors
        (memoize-restore f)
        (memoize f)))
    (message "Reset all-the-icons"))

  (add-to-list 'all-the-icons-mode-icon-alist
               '(xwidget-webkit-mode all-the-icons-faicon "chrome" :v-adjust -0.1 :face all-the-icons-blue))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(bongo-playlist-mode all-the-icons-material "playlist_play" :height 1.2 :v-adjust -0.2 :face 'all-the-icons-green))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(bongo-library-mode all-the-icons-material "library_music" :height 1.1 :v-adjust -0.2 :face 'all-the-icons-dgreen))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(gnus-group-mode all-the-icons-fileicon "gnu" :face 'all-the-icons-silver))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(gnus-summary-mode all-the-icons-octicon "inbox" :height 1.0 :v-adjust 0.0 :face 'all-the-icons-orange))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(gnus-article-mode all-the-icons-octicon "mail" :height 1.1 :v-adjust 0.0 :face 'all-the-icons-lblue))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(message-mode all-the-icons-octicon "mail" :height 1.1 :v-adjust 0.0 :face 'all-the-icons-lblue))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(diff-mode all-the-icons-octicon "git-compare" :v-adjust 0.0 :face all-the-icons-lred))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(flycheck-error-list-mode all-the-icons-octicon "checklist" :height 1.1 :v-adjust 0.0 :face all-the-icons-lred))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.[bB][iI][nN]$" all-the-icons-octicon "file-binary" :v-adjust 0.0 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.c?make$" all-the-icons-fileicon "gnu" :face all-the-icons-dorange))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.conf$" all-the-icons-octicon "settings" :v-adjust 0.0 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.toml$" all-the-icons-octicon "settings" :v-adjust 0.0 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(conf-mode all-the-icons-octicon "settings" :v-adjust 0.0 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(conf-space-mode all-the-icons-octicon "settings" :v-adjust 0.0 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(forge-topic-mode all-the-icons-alltheicon "git" :face all-the-icons-blue))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.xpm$" all-the-icons-octicon "file-media" :v-adjust 0.0 :face all-the-icons-dgreen))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(help-mode all-the-icons-faicon "info-circle" :height 1.1 :v-adjust -0.1 :face all-the-icons-purple))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(helpful-mode all-the-icons-faicon "info-circle" :height 1.1 :v-adjust -0.1 :face all-the-icons-purple))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(Info-mode all-the-icons-faicon "info-circle" :height 1.1 :v-adjust -0.1))
  (add-to-list 'all-the-icons-icon-alist
               '("NEWS$" all-the-icons-faicon "newspaper-o" :height 0.9 :v-adjust -0.2))
  (add-to-list 'all-the-icons-icon-alist
               '("Cask\\'" all-the-icons-fileicon "elisp" :height 1.0 :v-adjust -0.2 :face all-the-icons-blue))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(cask-mode all-the-icons-fileicon "elisp" :height 1.0 :v-adjust -0.2 :face all-the-icons-blue))
  (add-to-list 'all-the-icons-icon-alist
               '(".*\\.ipynb\\'" all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-orange))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(ein:notebooklist-mode all-the-icons-faicon "book" :face all-the-icons-lorange))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(ein:notebook-mode all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-orange))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(ein:notebook-multilang-mode all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-dorange))
  (add-to-list 'all-the-icons-icon-alist
               '("\\.epub\\'" all-the-icons-faicon "book" :height 1.0 :v-adjust -0.1 :face all-the-icons-green))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(nov-mode all-the-icons-faicon "book" :height 1.0 :v-adjust -0.1 :face all-the-icons-green))
  (add-to-list 'all-the-icons-mode-icon-alist
               '(gfm-mode all-the-icons-octicon "markdown" :face all-the-icons-lblue)))

(use-package olivetti
  :straight (:host github :repo "rnkn/olivetti")
  :commands (olivetti-mode olivetti-shrink olivetti-expand olivetti-set-width)
  :custom
  (olivetti-body-width 120))
;; -ATIPac

(use-package popper
  :defines popper-echo-dispatch-actions
  :hook (window-setup . popper-mode)
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$" "\\*Pp Eval Output\\*$"
          "\\*Completions\\*"
          "\\*Warnings\\*"
          "\\*Async Shell Command\\*"
          "\\*Apropos\\*"
          "\\*Backtrace\\*"
          "\\*Agenda Commands\\*"
          "\\*eldoc\\*"
          "\\*Calendar\\*"

          bookmark-bmenu-mode
          compilation-mode
          help-mode helpful-mode
          tabulated-list-mode
          Buffer-menu-mode

          gnus-article-mode devdocs-mode
          grep-mode rg-mode deadgrep-mode ag-mode pt-mode
          ;; occur-mode
          ivy-occur-mode ivy-occur-grep-mode
          process-menu-mode list-environment-mode cargo-process-mode
          youdao-dictionary-mode osx-dictionary-mode fanyi-mode

          "^\\*eshell.*\\*$" eshell-mode
          "^\\*shell.*\\*$"  shell-mode
          "^\\*term.*\\*$"   term-mode

          "\\*DAP Templates\\*$" dap-server-log-mode
          "\\*ELP Profiling Restuls\\*" profiler-report-mode
          "\\*Flycheck errors\\*$" " \\*Flycheck checker\\*$"
          "\\*Paradox Report\\*$" "\\*package update results\\*$" "\\*Package-Lint\\*$"
          "\\*[Wo]*Man.*\\*$"
          "\\*ert\\*$" overseer-buffer-mode
          "\\*gud-debug\\*$"
          "\\*lspce-hover\\*"
          "\\*lsp-help\\*$" "\\*lsp session\\*$"
          "\\*quickrun\\*$"
          "\\*tldr\\*$"
          "\\*vc-.*\\*$"
          "^\\*elfeed-entry\\*$"
          "^\\*macro expansion\\**"
          "\\*Flymake diagnostics .*\\*$"

          ;; "\\*Org Select\\*" "\\*Capture\\*" "^CAPTURE-.*\\.org*"
          "\\*Gofmt Errors\\*$" "\\*Go Test\\*$" godoc-mode
          "\\*docker-containers\\*" "\\*docker-images\\*" "\\*docker-networks\\*" "\\*docker-volumes\\*"
          "\\*prolog\\*" inferior-python-mode inf-ruby-mode swift-repl-mode
          "\\*rustfmt\\*$" rustic-compilation-mode rustic-cargo-clippy-mode
          rustic-cargo-outdated-mode rustic-cargo-test-moed))

  (setq popper-echo-dispatch-actions t)
  :config
  (popper-echo-mode 1)
  (with-no-warnings
    (defun popper-close-window-hack (&rest _)
      "Close popper window via `C-g'."
      ;; `C-g' can deactivate region
      (when (and (called-interactively-p 'interactive)
                 (not (region-active-p))
                 popper-open-popup-alist)
        (let ((window (caar popper-open-popup-alist)))
          (when (window-live-p window)
            (delete-window window)))))
    (advice-add #'keyboard-quit :before #'popper-close-window-hack)))


(use-package ef-themes
  :init
  ;;  HACK: do not load unused themes
  (dolist (theme '(ef-winter ef-tritanopia-dark ef-trio-dark ef-night ef-duo-dark ef-deuteranopia-dark ef-dark ef-cherie ef-bio ef-autumn ef-tritanopia-light ef-summer ef-spring ef-light ef-frost ef-duo-light ef-deuteranopia-light ef-day ef-cyprus ef-trio-light))
    (add-to-list 'custom-known-themes theme))
  (ef-themes-select 'ef-trio-light)
  :config
  (with-eval-after-load 'org
    ;; (custom-set-faces '(org-done ((t (:foreground "gray")))))
    (setq org-todo-keyword-faces
          `(("TODO" . (:foreground ,(ef-themes-with-colors red-cooler) :weight bold))
            ("INPROCESS"  . ,(ef-themes-with-colors yellow-warmer))
            ("PROJ"  . ,(ef-themes-with-colors cyan-cooler))
            ("WAITING" . ,(ef-themes-with-colors fg-dim))
            ;; ("DONE" . (:foreground ,(ef-themes-with-colors fg-alt) :strike-through t))
            ("DONE" . (:foreground "gray" :strike-through t))
            ("CANCELED" . (:foreground ,(ef-themes-with-colors fg-dim) :weight bold :strike-through t))))
    )
  )

;; DoomModeline
(use-package doom-modeline
  :hook (window-setup . doom-modeline-mode)
  :custom-face
  (doom-modeline-buffer-modified ((t (:inherit (error bold) :background unspecified))))
  :custom
  (doom-modeline-unicode-fallback t)
  (doom-modeline-icon t)
  (doom-modeline-env-version t)
  (doom-modeline-major-mode-color-icon t)
  (doom-modeline-height 15)
  (doom-modeline-bar-width 1)
  (doom-modeline-time-icon nil)
  )
;; -DoomModeline
#+end_src
** Pretty Code
#+begin_src emacs-lisp
;;;###autoload
(defvar +pretty-code-symbols-alist '((t))
  "An alist containing a mapping of major modes to its value for
`prettify-symbols-alist'.")


(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))

;;;###autodef
(defun set-pretty-symbols! (modes &rest plist)
  "Associates string patterns with icons in certain major-modes.
  MODES is a major mode symbol or a list of them.
  PLIST is a property list whose keys must match keys in `+pretty-code-symbols',
and whose values are strings representing the text to be replaced with that
symbol. If the car of PLIST is nil, then unset any pretty symbols previously
defined for MODES.
This function accepts one special property:
  :alist ALIST
    Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
    `+pretty-code-symbols'.
For example, the rule for emacs-lisp-mode is very simple:
  (set-pretty-symbols! 'emacs-lisp-mode
    :lambda \"lambda\")
This will replace any instances of \"lambda\" in emacs-lisp-mode with the symbol
assicated with :lambda in `+pretty-code-symbols'.
Pretty symbols can be unset for emacs-lisp-mode with:
  (set-pretty-symbols! 'emacs-lisp-mode nil)"
  (declare (indent defun))
  (if (null (car-safe plist))
      (dolist (mode (doom-enlist modes))
        (assq-delete-all mode +pretty-code-symbols-alist))
    (let (results)
      (while plist
        (let ((key (pop plist)))
          (if (eq key :alist)
              (prependq! results (pop plist))
            (when-let (char (plist-get +pretty-code-symbols key))
              (push (cons (pop plist) char) results)))))
      (dolist (mode (doom-enlist modes))
        (setf (alist-get mode +pretty-code-symbols-alist)
              (if-let (old-results (alist-get mode +pretty-code-symbols-alist))
                  (dolist (cell results old-results)
                    (setf (alist-get (car cell) old-results) (cdr cell)))
                results))))))

(defvar +pretty-code-symbols
  '(;; org
    :name          "»"
    :src_block     "»"
    :src_block_end "«"
    ;; Functional
    :lambda        "λ"
    :def           "ƒ"
    :composition   "∘"
    :map           "↦"
    ;; Types
    :null          "∅"
    :true          "𝕋"
    :false         "𝔽"
    :int           "ℤ"
    :float         "ℝ"
    :str           "𝕊"
    :bool          "𝔹"
    ;; Flow
    :not           "￢"
    :in            "∈"
    :not-in        "∉"
    :and           "∧"
    :or            "∨"
    :for           "∀"
    :some          "∃"
    :return        "⟼"
    :yield         "⟻"
    ;; Other
    :<=  8804
    :>=  8805
    :tuple         "⨂"
    :dot           "•"
    :checkbox      "□"
    :pending       "■"
    :checkedbox    "☑"
    :list_property "∷"
    :ellipses      "…"
    :arrow_right   "→"
    :arrow_left    "←"
    :title         "❤"
    :subtitle      "𝙩"
    :author        "✍"
    :date          "⚓"
    :property      "☸"
    :options       "⌥"
    :latex_class   "🄲"
    :latex_header  "⇥"
    :beamer_header "↠"
    :attr_latex    "🄛"
    :attr_html     "🄗"
    :begin_quote   "❮"
    :end_quote     "❯"
    :caption       "☰"
    :header        "›"
    :results       "🍌"
    :begin_export  "⏩"
    :end_export    "⏪"
    :properties    "⚙"
    :end           "∎"
    :priority_a   "🄰"
    :priority_b   "🄱"
    :priority_c   "🄲"
    :priority_d   "🄳"
    ;; :priority_c   "🅲"
    )
  "Options plist for `set-pretty-symbols!'.
This should not contain any symbols from the Unicode Private Area! There is no
universal way of getting the correct symbol as that area varies from font to
font.")

(defvar +pretty-code-enabled-modes '(org-mode)
  "List of major modes in which `prettify-symbols-mode' should be enabled.
If t, enable it everywhere. If the first element is 'not, enable it in any mode
besides what is listed.")

;; When you get to the right edge, it goes back to how it normally prints
(setq prettify-symbols-unprettify-at-point 'right-edge)

(defun +pretty-code-init-pretty-symbols-h ()
  "Enable `prettify-symbols-mode'.
If in fundamental-mode, or a mode derived from special, comint, eshell or term
modes, this function does nothing.
Otherwise it builds `prettify-code-symbols-alist' according to
`+pretty-code-symbols-alist' for the current major-mode."
  (unless (or (eq major-mode 'fundamental-mode)
              (eq (get major-mode 'mode-class) 'special)
              (derived-mode-p 'comint-mode 'eshell-mode 'term-mode))
    (when (or (eq +pretty-code-enabled-modes t)
              (if (eq (car +pretty-code-enabled-modes) 'not)
                  (not (memq major-mode (cdr +pretty-code-enabled-modes)))
                (memq major-mode +pretty-code-enabled-modes)))
      (setq prettify-symbols-alist
            (append (cdr (assq major-mode +pretty-code-symbols-alist))
                    (default-value 'prettify-symbols-alist)))
      (when prettify-symbols-mode
        (prettify-symbols-mode -1))
      (prettify-symbols-mode +1))))

(add-hook 'after-change-major-mode-hook #'+pretty-code-init-pretty-symbols-h)

;; for Python-mode
;; (set-pretty-symbols! 'python-mode
;;   :>= ">="
;;   :<= "<="
;;   ;; Functional
;;   :def "def"
;;   :lambda "lambda"
;;   ;; Types
;;   :null "None"
;;   :true "True"
;;   :false "False"
;;   :int "int"
;;   :str "str"
;;   :float "float"
;;   :bool "bool"
;;   :tuple "tuple"
;;   ;; Flow
;;   :not "not"
;;   :in "in" :not-in "not in"
;;   :and "and" :or "or"
;;   :for "for"
;;   :return "return" :yield "yield")

(set-pretty-symbols! 'emacs-lisp-mode
  :lambda "lambda")

(set-pretty-symbols! 'org-mode
  :name "#+NAME:"
  :src_block "#+begin_src"
  :src_block_end "#+end_src"
  :src_block "#+begin_latex"
  :src_block_end "#+end_latex"
  ;; :checkbox      "[ ]"
  ;; :pending       "[-]"
  ;; :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_latex:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  ;; :priority_a    "[#A]"
  ;; :priority_b    "[#B]"
  ;; :priority_c    "[#C]"
  ;; :priority_d    "[#D]"
  )
#+end_src
** Highlight
#+begin_src emacs-lisp
;; Highlight the current line
(use-package hl-line
  :custom-face (hl-line ((t (:extend t))))
  :hook ((after-init . global-hl-line-mode)
         ((term-mode vterm-mode) . hl-line-unload-function)))

;; Highlight symbols
(use-package symbol-overlay

  :functions (turn-off-symbol-overlay turn-on-symbol-overlay)
  :custom-face (symbol-overlay-default-face ((t (:inherit (region bold)))))
  :hook ((prog-mode . symbol-overlay-mode)
         (iedit-mode . turn-off-symbol-overlay)
         (iedit-mode-end . turn-on-symbol-overlay))
  :init (setq symbol-overlay-idle-time 0.1)
  (with-eval-after-load 'all-the-icons
    (setq symbol-overlay-faces
          '((:inherit (all-the-icons-blue bold) :inverse-video t)
            (:inherit (all-the-icons-pink bold) :inverse-video t)
            (:inherit (all-the-icons-yellow bold) :inverse-video t)
            (:inherit (all-the-icons-purple bold) :inverse-video t)
            (:inherit (all-the-icons-red bold) :inverse-video t)
            (:inherit (all-the-icons-orange bold) :inverse-video t)
            (:inherit (all-the-icons-green bold) :inverse-video t)
            (:inherit (all-the-icons-cyan bold) :inverse-video t))))
  :config
  ;; Disable symbol highlighting while selecting
  (defun turn-off-symbol-overlay (&rest _)
    "Turn off symbol highlighting."
    (interactive)
    (symbol-overlay-mode -1))
  (advice-add #'set-mark :after #'turn-off-symbol-overlay)

  (defun turn-on-symbol-overlay (&rest _)
    "Turn on symbol highlighting."
    (interactive)
    (when (derived-mode-p 'prog-mode)
      (symbol-overlay-mode 1)))
  (advice-add #'deactivate-mark :after #'turn-on-symbol-overlay))

;; Highlight brackets according to their depth
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

;; Highlight TODO and similar keywords in comments and strings
(use-package hl-todo
  :hook ((prog-mode LaTeX-mode) . hl-todo-mode)
  :config
  (dolist (keyword '("BUG" "DEFECT" "ISSUE"))
    (cl-pushnew `(,keyword . ,(face-foreground 'error)) hl-todo-keyword-faces))
  (dolist (keyword '("WORKAROUND" "HACK" "TRICK"))
    (cl-pushnew `(,keyword . ,(face-foreground 'warning)) hl-todo-keyword-faces)))

;; Highlight uncommitted changes using VC
(use-package diff-hl
  :custom-face
  (diff-hl-change ((t (:foreground ,(face-background 'highlight) :background unspecified))))
  (diff-hl-insert ((t (:background unspecified))))
  (diff-hl-delete ((t (:background unspecified))))
  :hook ((find-file . diff-hl-mode)
         (vc-dir-mode . diff-hl-dir-mode)
         (dired-mode . diff-hl-dired-mode-unless-remote))
  :init (setq diff-hl-draw-borders nil)
  :config
  (add-hook 'after-change-major-mode-hook 'diff-hl-update-once)

  ;; Set fringe style
  (setq-default fringes-outside-margins t)

  (defun my-diff-hl-fringe-bmp-function (_type _pos)
    "Fringe bitmap function for use as `diff-hl-fringe-bmp-function'."
    (define-fringe-bitmap 'my-diff-hl-bmp
      (vector (if *sys/mac* #b11100000 #b11111100))
      1 8
      '(center t)))
  (setq diff-hl-fringe-bmp-function #'my-diff-hl-fringe-bmp-function)

  ;; Integration with magit
  (with-eval-after-load 'magit
    (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)))

;; Highlight some operations
(use-package volatile-highlights

  :hook (+my/first-input . volatile-highlights-mode)
  :config
  (vhl/define-extension 'evil 'evil-paste-after 'evil-paste-before
                        'evil-paste-pop 'evil-move)
  (vhl/install-extension 'evil)
  (when (fboundp 'pulse-momentary-highlight-region)
    (defun my-vhl-pulse (beg end &optional _buf face)
      "Pulse the changes."
      (pulse-momentary-highlight-region beg end face))
    (advice-add #'vhl/.make-hl :override #'my-vhl-pulse)))

;; Pulse current line
(use-package pulse
  :custom-face
  (pulse-highlight-start-face ((t (:inherit region))))
  (pulse-highlight-face ((t (:inherit region))))
  :hook (((dumb-jump-after-jump
           imenu-after-jump) . my-recenter-and-pulse)
         ((bookmark-after-jump
           magit-diff-visit-file
           next-error) . my-recenter-and-pulse-line))
  :init
  (defun my-pulse-momentary-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (defun my-pulse-momentary (&rest _)
    "Pulse the region or the current line."
    (if (fboundp 'xref-pulse-momentarily)
        (xref-pulse-momentarily)
      (my-pulse-momentary-line)))

  (defun my-recenter-and-pulse(&rest _)
    "Recenter and pulse the region or the current line."
    (recenter)
    (my-pulse-momentary))

  (defun my-recenter-and-pulse-line (&rest _)
    "Recenter and pulse the current line."
    (recenter)
    (my-pulse-momentary-line))

  (dolist (cmd '(recenter-top-bottom
                 other-window windmove-do-window-select
                 ace-window aw--select-window
                 pager-page-down pager-page-up
                 treemacs-select-window
                 symbol-overlay-basic-jump))
    (advice-add cmd :after #'my-pulse-momentary-line))

  (dolist (cmd '(pop-to-mark-command
                 pop-global-mark
                 goto-last-change))
    (advice-add cmd :after #'my-recenter-and-pulse)))
#+end_src
* Program
** Paren
#+begin_src emacs-lisp
(use-package paren
  :hook (after-init . show-paren-mode)
  :init (setq show-paren-when-point-inside-paren t
              show-paren-when-point-in-periphery t
              show-paren-style 'parenthesis
              show-paren-context-when-offscreen 'overlay))

;; Automatic parenthesis pairing
(use-package elec-pair
  :hook (+my/first-input . electric-pair-mode)
  :init (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  :config
  ;; disable <> auto pairing in electric-pair-mode for org-mode
  (add-hook 'org-mode-hook
            #'(lambda ()
                (setq-local electric-pair-inhibit-predicate
                            `(lambda (c)
                               (if (char-equal c ?<) t
                                 (,electric-pair-inhibit-predicate c)))))))

(with-eval-after-load 'evil
  (defun my/evil-paren-range (count beg end type inclusive)
    "Get minimum range of paren text object.
COUNT, BEG, END, TYPE is used.  If INCLUSIVE is t, the text object is inclusive."
    (let* ((cur_point (point))
           (parens '("()" "[]" "{}" "<>"))
           (quotes '("\"" "'"))
           (pqs (append parens quotes))
           range
           found-range)
      ;;  HACK: ' is widely used in lisp
      (when (derived-mode-p 'emacs-lisp-mode)
        (setq pqs (butlast pqs)))
      (dolist (p pqs)
        (save-excursion
          (ignore-errors
            (if (member p parens)
                (setq range (evil-select-paren (aref p 0) (aref p 1) beg end type count inclusive))
              (setq range (evil-select-quote (aref p 0) beg end type count)))))
        (when (and range
                   (<= (nth 0 range) cur_point)
                   (>= (nth 1 range) cur_point))
          (cond
           (found-range
            (when (and
                   (< (- (nth 1 range) (nth 0 range))
                      (- (nth 1 found-range) (nth 0 found-range))))
              (setf (nth 0 found-range) (nth 0 range))
              (setf (nth 1 found-range) (nth 1 range))))
           (t
            (setq found-range range)))))
      found-range))
  (evil-define-text-object my/evil-a-paren (count &optional beg end type)
    "Select a paren."
    :extend-selection t
    (my/evil-paren-range count beg end type t))

  (evil-define-text-object my/evil-inner-paren (count &optional beg end type)
    "Select 'inner' paren."
    :extend-selection nil
    (my/evil-paren-range count beg end type nil))
  (define-key evil-inner-text-objects-map "g" #'my/evil-inner-paren)
  (define-key evil-outer-text-objects-map "g" #'my/evil-a-paren)

  (defun my/edit-kill ()
    (interactive)
    (let* ((parens '("(" ")" "[" "]" "{" "}" "<" ">" "\""))
           (char (string (char-after))))
      ;;  HACK: ' is widely used in lisp
      (when (not (derived-mode-p 'emacs-lisp-mode))
        (push "'" parens))
      (setq unread-command-events
            (append (apply 'vconcat (mapcar 'kbd
                                            (if (and (not (nth 3 (syntax-ppss)))
                                                     (member char parens))
                                                `("d" "a" ,char)
                                              ;; '("d" "i" "g")
                                              ;;  HACK: Don't know why dig not works
                                              '("v" "i" "g" "x")
                                              ))) nil))))
  (with-eval-after-load 'general
    (general-define-key
     :keymaps '(evil-normal-state-map)
     "C-k" 'my/edit-kill)))
#+end_src
** Indent
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default indent-line-function 'insert-tab)
(setq-default tab-width 4)

(defun toggle-indent (&optional indent)
  "Toggle indent based on `evil-auto-indent'"
  (interactive (list evil-auto-indent))
  (if indent
      (progn
        (electric-indent-local-mode -1)
        (setq-local evil-auto-indent nil))
    (progn
      (electric-indent-local-mode 1)
      (setq-local evil-auto-indent t))))

(dolist (hook '(text-mode-hook conf-mode-hook conf-space-mode-hook))
  (add-hook hook (lambda ()
                   (toggle-indent t))))
#+end_src
** Tree sitter
#+begin_src emacs-lisp
(use-package tree-sitter
  :defer t
  :commands tree-sitter-hl-mode
  :hook ((python-mode) . tree-sitter-hl-mode))

(use-package tree-sitter-langs
  :defer t
  :after tree-sitter)

;;  TODO: replace `tree-sitter'
(use-package treesit
  :if (treesit-available-p)
  :straight (:type built-in)
  :init
  ;; WORKAROUND: set source alist manually
  (setq treesit-language-source-alist
        '((bash       . ("https://github.com/tree-sitter/tree-sitter-bash.git"))
          (c          . ("https://github.com/tree-sitter/tree-sitter-c.git"))
          (json       . ("https://github.com/tree-sitter/tree-sitter-json.git"))
          (python     . ("https://github.com/tree-sitter/tree-sitter-python.git"))
          (toml       . ("https://github.com/tree-sitter/tree-sitter-toml.git"))
          (yaml       . ("https://github.com/ikatyang/tree-sitter-yaml.git"))))
  :config
  (setq major-mode-remap-alist
        '((yaml-mode . yaml-ts-mode)
          ;; (python-mode . python-ts-mode)
          (js-json-mode . json-ts-mode)
          (sh-mode . bash-ts-mode)))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))
)
#+end_src
** LSP
#+begin_src emacs-lisp
(use-package eglot
  :straight nil
  :commands (+eglot-help-at-point)
  :hook (
         (eglot-managed-mode . (lambda ()
                                 (+lsp-optimization-mode)
                                 (leader-def :keymaps 'override
                                   "ca" '(eglot-code-actions :wk "Code Actions")
                                   "cr" '(eglot-rename :wk "Rename symbol")
                                   "cI" '(eglot-code-action-organize-imports :wk "Organize import")
                                   "cJ" '(consult-eglot-symbols :wk "Symbols in project")
                                   "cd" '(eglot-find-declaration :wk "Jump to definition")
                                   "cF" '(eglot-find-implementation :wk "Find implementation")
                                   "cD" '(eglot-find-typeDefinition :wk "Find type definition"))

                                 (evil-define-key 'normal 'global
                                   "K" '+eglot-help-at-point)
                                 ))
         ((python-mode c-mode c++-mode LaTeX-mode) . eglot-ensure)
         )
  :init
  (defvar +lsp--default-read-process-output-max nil)
  (defvar +lsp--default-gcmh-high-cons-threshold nil)
  (defvar +lsp--optimization-init-p nil)

  (define-minor-mode +lsp-optimization-mode
    "Deploys universal GC and IPC optimizations for `lsp-mode' and `eglot'."
    :global t
    :init-value nil
    (if (not +lsp-optimization-mode)
        (setq-default read-process-output-max +lsp--default-read-process-output-max
                      gcmh-high-cons-threshold +lsp--default-gcmh-high-cons-threshold
                      +lsp--optimization-init-p nil)
      ;; Only apply these settings once!
      (unless +lsp--optimization-init-p
        (setq +lsp--default-read-process-output-max
              ;; DEPRECATED Remove check when 26 support is dropped
              (if (boundp 'read-process-output-max)
                  (default-value 'read-process-output-max))
              +lsp--default-gcmh-high-cons-threshold
              (default-value 'gcmh-high-cons-threshold))
        ;; `read-process-output-max' is only available on recent development
        ;; builds of Emacs 27 and above.
        (setq-default read-process-output-max (* 1024 1024))
        ;; REVIEW LSP causes a lot of allocations, with or without Emacs 27+'s
        ;;        native JSON library, so we up the GC threshold to stave off
        ;;        GC-induced slowdowns/freezes. Doom uses `gcmh' to enforce its
        ;;        GC strategy, so we modify its variables rather than
        ;;        `gc-cons-threshold' directly.
        (setq-default gcmh-high-cons-threshold (* 2 +lsp--default-gcmh-high-cons-threshold))
        (gcmh-set-high-threshold)
        (setq +lsp--optimization-init-p t))))

  :config
  (use-package consult-eglot)
  (fset 'lsp-capf 'eglot-completion-at-point)
  (setq eglot-sync-connect 1
        eglot-connect-timeout 10
        eglot-autoshutdown t
        eglot-send-changes-idle-time 0
        eglot-events-buffer-size 0
        ;; NOTE We disable eglot-auto-display-help-buffer because :select t in
        ;;      its popup rule causes eglot to steal focus too often.
        eglot-auto-display-help-buffer nil)
  (setq eldoc-echo-area-use-multiline-p nil)
  (setq eglot-ignored-server-capabilities '(:documentHighlightProvider :foldingRangeProvider :colorProvider :codeLensProvider :documentOnTypeFormattingProvider :executeCommandProvider))
  (add-to-list 'eglot-server-programs '((latex-mode Tex-latex-mode texmode context-mode texinfo-mode bibtex-mode) "texlab"))

  ;; HACK Eglot removed `eglot-help-at-point' in joaotavora/eglot@a044dec for a
  ;;      more problematic approach of deferred to eldoc. Here, I've restored it.
  ;;      Doom's lookup handlers try to open documentation in a separate window
  ;;      (so they can be copied or kept open), but doing so with an eldoc buffer
  ;;      is difficult because a) its contents are generated asynchronously,
  ;;      making them tough to scrape, and b) their contents change frequently
  ;;      (every time you move your cursor).
  (defvar +eglot--help-buffer nil)
  (defun +eglot-lookup-documentation (_identifier)
    "Request documentation for the thing at point."
    (eglot--dbind ((Hover) contents range)
        (jsonrpc-request (eglot--current-server-or-lose) :textDocument/hover
                         (eglot--TextDocumentPositionParams))
      (let ((blurb (and (not (seq-empty-p contents))
                        (eglot--hover-info contents range)))
            (hint (thing-at-point 'symbol)))
        (if blurb
            (with-current-buffer
                (or (and (buffer-live-p +eglot--help-buffer)
                         +eglot--help-buffer)
                    (setq +eglot--help-buffer (generate-new-buffer "*eglot-help*")))
              (with-help-window (current-buffer)
                (rename-buffer (format "*eglot-help for %s*" hint))
                (with-current-buffer standard-output (insert blurb))
                (setq-local nobreak-char-display nil)))
          (display-local-help))))
    'deferred)

  (defun +eglot-help-at-point()
    (interactive)
    (+eglot-lookup-documentation nil)))
#+end_src
** Utils
#+begin_src emacs-lisp
(use-package devdocs
  :straight (:host github :repo "astoff/devdocs.el")
  :commands (devdocs-lookup-at-point devdocs-search-at-point)
  :config
  (add-hook 'python-mode-hook
            (lambda() (setq-local devdocs-current-docs '("python~3.9" "PyTorch" "NumPy~1.20"))))
  (defun devdocs-lookup-at-point()
    (interactive)
    (devdocs-lookup devdocs-current-docs (thing-at-point 'symbol)))
  (defun devdocs-search-at-point()
    (interactive)
    (devdocs-search (thing-at-point 'symbol))))

(use-package project
  :straight nil
  :after-call +my/first-input-hook-fun
  :config
  (defun my/project-files-in-directory (dir)
    "Use `fd' to list files in DIR."
    (let* ((default-directory dir)
           (localdir (file-local-name (expand-file-name dir)))
           (command (format "fd -H -t f -0 . %s" localdir)))
      (project--remote-file-names
       (sort (split-string (shell-command-to-string command) "\0" t)
             #'string<))))

  (cl-defmethod project-files ((project (head local)) &optional dirs)
    "Override `project-files' to use `fd' in local projects."
    (mapcan #'my/project-files-in-directory
            (or dirs (list (project-root project)))))

  (cl-defmethod project-root ((project (head local)))
    (nth 1 project))
  (defun my/project-try-local (dir)
    "Determine if DIR is a non-Git project."
    (catch 'ret
      (let ((pr-flags '((".project" ".projectile" ".rc_config")
                        ("Makefile" "README.org" "README.md"))))
        (dolist (current-level pr-flags)
          (dolist (f current-level)
            (when-let ((root (locate-dominating-file dir f)))
              (throw 'ret (list 'local root))))))))

  (setq project-find-functions '(project-try-vc my/project-try-local))

  ;;  auto remember project
  (add-hook 'change-major-mode-hook (lambda ()
                                      (when (and (buffer-file-name)
                                                 (not (string-match-p "^/\\(?:ssh\\|scp\\|su\\|sudo\\)?:" (buffer-file-name)))
                                                 (not (string-match-p "straight/repos" (buffer-file-name)))
                                                 (fboundp 'project-current))
                                        (when-let ((root (+my/project-root)))
                                          (project-remember-project (project-current)))))))


(use-package format-all

  :commands format-all-buffer
  :hook ((prog-mode) . format-all-ensure-formatter)
  )
#+end_src
** Language
*** Python
#+begin_src emacs-lisp
(use-package python
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :hook (inferior-python-mode . (lambda ()
                                  (process-query-on-exit-flag
                                   (get-process "Python"))))
  :init
  ;; Disable readline based native completion
  (setq python-shell-completion-native-enable nil)
  (setq python-indent-guess-indent-offset-verbose nil)
  :config

  (add-hook 'python-mode-hook (lambda ()
                                (setq-local tab-width 4)))

  (setq python-indent-offset 4
        python-shell-interpreter "python3"
        importmagic-python-interpreter "python"
        flycheck-python-flake8-executable "flake8")

  (use-package py-isort
    :hook (python-mode . (lambda ()
                           (add-hook 'before-save-hook #'py-isort-before-save nil t))))
  )
#+end_src
*** Latex
#+begin_src emacs-lisp
;; Fontification taken from https://tex.stackexchange.com/a/86119/81279
(setq font-latex-match-reference-keywords
      '(;; biblatex
        ("printbibliography" "[{")
        ("addbibresource" "[{")
        ;; Standard commands
        ("cite" "[{")
        ("citep" "[{")
        ("citet" "[{")
        ("Cite" "[{")
        ("parencite" "[{")
        ("Parencite" "[{")
        ("footcite" "[{")
        ("footcitetext" "[{")
        ;; Style-specific commands
        ("textcite" "[{")
        ("Textcite" "[{")
        ("smartcite" "[{")
        ("Smartcite" "[{")
        ("cite*" "[{")
        ("parencite*" "[{")
        ("supercite" "[{")
        ;; Qualified citation lists
        ("cites" "[{")
        ("Cites" "[{")
        ("parencites" "[{")
        ("Parencites" "[{")
        ("footcites" "[{")
        ("footcitetexts" "[{")
        ("smartcites" "[{")
        ("Smartcites" "[{")
        ("textcites" "[{")
        ("Textcites" "[{")
        ("supercites" "[{")
        ;; Style-independent commands
        ("autocite" "[{")
        ("Autocite" "[{")
        ("autocite*" "[{")
        ("Autocite*" "[{")
        ("autocites" "[{")
        ("Autocites" "[{")
        ;; Text commands
        ("citeauthor" "[{")
        ("Citeauthor" "[{")
        ("citetitle" "[{")
        ("citetitle*" "[{")
        ("citeyear" "[{")
        ("citedate" "[{")
        ("citeurl" "[{")
        ;; Special commands
        ("fullcite" "[{")
        ;; cleveref
        ("cref" "{")
        ("Cref" "{")
        ("cpageref" "{")
        ("Cpageref" "{")
        ("cpagerefrange" "{")
        ("Cpagerefrange" "{")
        ("crefrange" "{")
        ("Crefrange" "{")
        ("labelcref" "{")))

(setq font-latex-match-textual-keywords
      '(;; biblatex brackets
        ("parentext" "{")
        ("brackettext" "{")
        ("hybridblockquote" "[{")
        ;; Auxiliary Commands
        ("textelp" "{")
        ("textelp*" "{")
        ("textins" "{")
        ("textins*" "{")
        ;; subcaption
        ("subcaption" "[{")))

(setq font-latex-match-variable-keywords
      '(;; amsmath
        ("numberwithin" "{")
        ;; enumitem
        ("setlist" "[{")
        ("setlist*" "[{")
        ("newlist" "{")
        ("renewlist" "{")
        ("setlistdepth" "{")
        ("restartlist" "{")
        ("crefname" "{")))



(use-package reftex
  :after tex
  :hook (LaTeX-mode . reftex-mode)
  :custom
  (reftex-plug-into-AUCTeX t)
  (reftex-toc-split-windows-fraction 0.3)
  :config

  (defvar +my/reftex-citation-completion-table nil)

  (defun +my/reftex-find-citation (prefix)
    (reftex-access-scan-info)
    (setq +my/reftex-citation-completion-table
          (cl-letf (((symbol-function 'reftex--query-search-regexps)
                     (lambda (_) (if (string= prefix "")
                                (list ".+")
                              (list (regexp-quote prefix))))))
            (let* ((bibtype (reftex-bib-or-thebib))
                   (candidates
                    (cond
                     ((eq 'thebib bibtype)
                      (reftex-extract-bib-entries-from-thebibliography
                       (reftex-uniquify
                        (mapcar 'cdr
                                (reftex-all-assq
                                 'thebib (symbol-value reftex-docstruct-symbol))))))
                     ((eq 'bib bibtype)
                      (reftex-extract-bib-entries (reftex-get-bibfile-list)))
                     (reftex-default-bibliography
                      (reftex-extract-bib-entries (reftex-default-bibliography))))))
              (cl-loop
               for entry in candidates
               collect
               (let ((key (substring-no-properties (car entry)))
                     (annotate (reftex-format-citation entry "%t")))
                 (cons
                  (format "%s -> %s" key annotate)
                  key)))))
          )
    +my/reftex-citation-completion-table)

  (defcustom company-reftex-citations-regexp
    (rx "\\"
        ;; List taken from `reftex-cite-format-builtin'
        (or "autocite"
            "autocite*"
            "bibentry"
            "cite"
            "cite*"
            "citeA"
            "citeaffixed"
            "citeasnoun"
            "citeauthor"
            "citeauthor*"
            "citeauthory"
            "citefield"
            "citeN"
            "citename"
            "cites"
            "citet"
            "citet*"
            "citetitle"
            "citetitle*"
            "citep"
            "citeyear"
            "citeyear*"
            "footcite"
            "footfullcite"
            "fullcite"
            "fullocite"
            "nocite"
            "ocite"
            "ocites"
            "parencite"
            "parencite*"
            "possessivecite"
            "shortciteA"
            "shortciteN"
            "smartcite"
            "supercite"
            "textcite"
            "textcite*"
            "ycite"
            "ycites")
        (* (not (any "[{")))
        (* (seq "[" (* (not (any "]"))) "]"))
        "{"
        (* (seq (* (not (any "},"))) ","))
        (group (* (not (any "},")))))
    "Regular expression to use when lookng for the citation prefix.
Group number 1 should be the prefix itself."
    :type 'string
    :group 'company-reftex)
  (defun company-reftex-prefix (regexp)
    "Return the prefix for matching given REGEXP."
    (and (derived-mode-p 'latex-mode)
         reftex-mode
         (when (looking-back regexp nil)
           (match-string-no-properties 1))))

  (defun +my/reftex-citation-completion ()
    (when (company-reftex-prefix company-reftex-citations-regexp)
      (let ((bounds (bounds-of-thing-at-point 'symbol)))
        `(,(car bounds) ,(cdr bounds)
          ,(cape--table-with-properties
            (cape--cached-table (car bounds) (cdr bounds) #'+my/reftex-find-citation 'substring)
            :category 'cape-table)
          :exclusive 'no
          ;; :annotation-function (lambda (k) (cdr (assoc k table)))
          :exit-function (lambda (str sta)
                           (backward-delete-char (length str))
                           (insert (cdr (assoc str +my/reftex-citation-completion-table))))))))

  )

(use-package bibtex
  :after (org tex)
  :custom
  (bibtex-dialect 'biblatex)
  (bibtex-align-at-equal-sign t)
  (bibtex-text-indentation 20)
  )


(use-package latex
  :straight auctex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook (LaTeX-mode . outline-minor-mode)
  :custom
  (TeX-insert-braces nil)
  (TeX-parse-self t) ; parse on load
  (TeX-auto-save t)  ; parse on save
  ;; use hidden dirs for auctex files
  (TeX-auto-local ".auctex-auto")
  (TeX-style-local ".auctex-style")
  (TeX-source-correlate-mode t)
  (TeX-source-correlate-method 'synctex)
  ;; don't start the emacs server when correlating sources
  (TeX-source-correlate-start-server nil)
  ;; automatically insert braces after sub/superscript in math mode
  (TeX-electric-sub-and-superscript t)
  (TeX-master nil)

  (LaTeX-section-hook ; Add the toc entry to the sectioning hooks.
   '(LaTeX-section-heading
     LaTeX-section-title
     LaTeX-section-toc
     LaTeX-section-section
     LaTeX-section-label))
  (LaTeX-fill-break-at-separators nil)

  :config
  (add-hook 'LaTeX-mode-hook (lambda ()
                               (push
                                '("latexmk" "latexmk -pdf -pvc -view=none %s" TeX-run-TeX nil t :help "Run latexmk on file")
                                TeX-command-list)
                               (push
                                '("xelatex" "xelatex %s" TeX-run-TeX nil t :help "Run xelatex for CJK")
                                TeX-command-list)
                               (setq TeX-command-list (delete-dups TeX-command-list))
                               ))
  ;; use Skim as default pdf viewer
  ;; Skim's displayline is used for forward search (from .tex to .pdf)
  ;; option -b highlights the current line; option -g opens Skim in the background
  (setq TeX-view-program-list
        '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -g %n %o %b")))
  (assq-delete-all 'output-pdf TeX-view-program-selection)
  (add-to-list 'TeX-view-program-selection '(output-pdf "PDF Viewer"))


  (defun latex/compile-commands-until-done (clean-first)
    (interactive "P")
    (save-buffer)
    (when clean-first (TeX-clean t))
    (message "Compilation started.")
    (let* ((initial-buffer (buffer-name))
           (TeX-process-asynchronous nil)
           (master-file (TeX-master-file))
           (next-command (TeX-command-default master-file))
           (counter 0))
      (while (and
              (> counter -1)
              (not (equal next-command TeX-command-Show)))
        (message "%d Doing: %s" (cl-incf counter) next-command)
        (set-buffer initial-buffer)
        (TeX-command next-command 'TeX-master-file)
        ;; `TeX-command' occasionally changes current buffer.
        (set-buffer initial-buffer)
        (if (null (plist-get TeX-error-report-switches (intern master-file)))
            ;; (if (string= next-command "BibTeX")
            ;;     (setq next-command "LaTeX")
              ;; (setq next-command (TeX-command-default master-file)))
              (setq next-command (TeX-command-default master-file))
          (setq counter -1)
          (when (y-or-n-p "Error found. Visit it? ")
            ;; `TeX-next-error' number of arguments changed at some
            ;; point.
            (call-interactively #'TeX-next-error))))
      (when (>= counter 0) ;;
        (set-buffer initial-buffer)
        (TeX-view))))

  (setcar (cdr (assoc "Check" TeX-command-list)) "chktex -v6 -H %s")

  (local-leader-def
    :keymaps 'LaTeX-mode-map
    "m" '(TeX-master-file-ask :wk "Master file")
    "c" '(latex/compile-commands-until-done :wk "Compile")
    "v" '(TeX-view :wk "View"))
  )

(use-package cdlatex
  :after tex
  :hook (LaTeX-mode . cdlatex-mode)
  :custom
  (cdlatex-sub-super-scripts-outside-math-mode nil)
  :config
  (add-to-list 'cdlatex-math-modify-alist-default '(?b "\\bm" nil t t nil))
  (add-to-list 'cdlatex-math-modify-alist-default '(?B "\\mathbb" nil t t nil))
  )

(use-package asymbol
  :straight (:host github :repo "dwuggh/asymbol" :depth 1)
  :hook (LaTeX-mode . asymbol-mode)
  :init
  (setq asymbol-help-symbol-linewidth 110
	    asymbol-help-tag-linewidth 110)

  :config
  (add-hook 'org-cdlatex-mode-hook
            (lambda () (define-key org-cdlatex-mode-map "`" 'asymbol-insert-text-or-symbol)))
  )
#+end_src
*** Org
#+begin_src emacs-lisp
;;  TODO: remove unused codes

;;
;;; Row/Column traversal

;;;###autoload
(defun +org/table-previous-row ()
  "Go to the previous row (same column) in the current table. Before doing so,
re-align the table if necessary. (Necessary because org-mode has a
`org-table-next-row', but not `org-table-previous-row')"
  (interactive)
  (org-table-maybe-eval-formula)
  (org-table-maybe-recalculate-line)
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (beginning-of-line 0)
    (when (or (not (org-at-table-p)) (org-at-table-hline-p))
      (beginning-of-line))
    (org-table-goto-column col)
    (skip-chars-backward "^|\n\r")
    (when (org-looking-at-p " ")
      (forward-char))))

;;
;;; Hooks

;;;###autoload
(defun +org-realign-table-maybe-h ()
  "Auto-align table under cursor."
  (when (and (org-at-table-p) org-table-may-need-update)
    (let ((pt (point))
          (inhibit-message t))
      ;; (org-table-recalculate)
      (if org-table-may-need-update (org-table-align))
      (goto-char pt))))

;;
;;; Advice

;;;###autoload
(defun +org-realign-table-maybe-a (&rest _)
  "Auto-align table under cursor and re-calculate formulas."
  (when (eq major-mode 'org-mode)
    (+org-realign-table-maybe-h)))

;;;###autoload
(defun +org--refresh-inline-images-in-subtree ()
  "Refresh image previews in the current heading/tree."
  (if (> (length org-inline-image-overlays) 0)
      (org-remove-inline-images)
    (org-display-inline-images
     t t
     (if (org-before-first-heading-p)
         (line-beginning-position)
       (save-excursion (org-back-to-heading) (point)))
     (if (org-before-first-heading-p)
         (line-end-position)
       (save-excursion (org-end-of-subtree) (point))))))

(defun +org--insert-item (direction)
  (let* ((context
          (save-excursion
            (when (bolp)
              (back-to-indentation)
              (forward-char))
            (org-element-lineage
             (org-element-context)
             '(table table-row headline inlinetask item plain-list)
             t)))
         (type (org-element-type context)))
    (cond ((memq type '(item plain-list))
           (let ((marker (org-element-property :bullet context))
                 (pad (save-excursion
                        (org-beginning-of-item)
                        (back-to-indentation)
                        (- (point) (line-beginning-position)))))
             (save-match-data
               (pcase direction
                 (`below
                  (org-end-of-item)
                  (backward-char)
                  (end-of-line)
                  (if (and marker (string-match "\\([0-9]+\\)\\([).] *\\)" marker))
                      (let ((l (line-number-at-pos)))
                        (org-insert-item)
                        (when (= l (line-number-at-pos))
                          (org-next-item)
                          (org-end-of-line)))
                    (insert "\n" (make-string pad 32) (or marker ""))))
                 (`above
                  (org-beginning-of-item)
                  (if (and marker (string-match-p "[0-9]+[).]" marker))
                      (org-insert-item)
                    (insert (make-string pad 32) (or marker ""))
                    (save-excursion (insert "\n")))))))
           (when (org-element-property :checkbox context)
             (insert "[ ] ")))

          ((memq type '(table table-row))
           (pcase direction
             ('below (save-excursion (org-table-insert-row t))
                     (org-table-next-row))
             ('above (save-excursion (org-shiftmetadown))
                     (+org/table-previous-row))))

          ((let ((level (or (org-current-level) 1)))
             (pcase direction
               (`below
                (let (org-insert-heading-respect-content)
                  (goto-char (line-end-position))
                  (org-end-of-subtree)
                  (insert "\n" (make-string level ?*) " ")))
               (`above
                (org-back-to-heading)
                (insert (make-string level ?*) " ")
                (save-excursion (insert "\n"))))
             (when-let* ((todo-keyword (org-element-property :todo-keyword context))
                         (todo-type (org-element-property :todo-type context)))
               (org-todo (cond ((eq todo-type 'done)
                                (car (+org-get-todo-keywords-for todo-keyword)))
                               (todo-keyword)
                               ('todo)))))))

    (when (org-invisible-p)
      (org-show-hidden-entry))
    (when (and (bound-and-true-p evil-local-mode)
               (not (evil-emacs-state-p)))
      (evil-insert 1))))

;;;###autoload
(defun +org-get-todo-keywords-for (&optional keyword)
  "Returns the list of todo keywords that KEYWORD belongs to."
  (when keyword
    (cl-loop for (type . keyword-spec)
             in (cl-remove-if-not #'listp org-todo-keywords)
             for keywords =
             (mapcar (lambda (x) (if (string-match "^\\([^(]+\\)(" x)
                                     (match-string 1 x)
                                   x))
                     keyword-spec)
             if (eq type 'sequence)
             if (member keyword keywords)
             return keywords)))

;;
;;; Commands

;;;###autoload
(defun +org/dwim-at-point ()
  "Do-what-I-mean at point.

If on a:
- checkbox list item or todo heading: toggle it.
- clock: update its time.
- headline: toggle latex fragments and inline images underneath.
- footnote reference: jump to the footnote's definition
- footnote definition: jump to the first reference of this footnote
- table-row or a TBLFM: recalculate the table's formulas
- table-cell: clear it and go into insert mode. If this is a formula cell,
  recaluclate it instead.
- babel-call: execute the source block
- statistics-cookie: update it.
- latex fragment: toggle it.
- link: follow it
- otherwise, refresh all inline images in current tree."
  (interactive)
  (let* ((context (org-element-context))
         (type (org-element-type context)))
    ;; skip over unimportant contexts
    (while (and context (memq type '(verbatim code bold italic underline strike-through subscript superscript)))
      (setq context (org-element-property :parent context)
            type (org-element-type context)))
    (pcase type
      (`headline
       (cond ((and (fboundp 'toc-org-insert-toc)
                   (member "TOC" (org-get-tags)))
              (toc-org-insert-toc)
              (message "Updating table of contents"))
             ((string= "ARCHIVE" (car-safe (org-get-tags)))
              (org-force-cycle-archived))
             ((or (org-element-property :todo-type context)
                  (org-element-property :scheduled context))
              (org-todo
               (if (eq (org-element-property :todo-type context) 'done)
                   (or (car (+org-get-todo-keywords-for (org-element-property :todo-keyword context)))
                       'todo)
                 'done)))
             (t
              (+org--refresh-inline-images-in-subtree)
              (org-clear-latex-preview)
              (org-latex-preview '(4)))))

      (`clock (org-clock-update-time-maybe))

      (`footnote-reference
       (org-footnote-goto-definition (org-element-property :label context)))

      (`footnote-definition
       (org-footnote-goto-previous-reference (org-element-property :label context)))

      ((or `planning `timestamp)
       (org-follow-timestamp-link))

      ((or `table `table-row)
       (if (org-at-TBLFM-p)
           (org-table-calc-current-TBLFM)
         (ignore-errors
           (save-excursion
             (goto-char (org-element-property :contents-begin context))
             (org-call-with-arg 'org-table-recalculate (or arg t))))))

      (`table-cell
       (org-table-blank-field)
       (org-table-recalculate)
       (when (and (string-empty-p (string-trim (org-table-get-field)))
                  (bound-and-true-p evil-local-mode))
         (evil-change-state 'insert)))

      (`src-block
       (org-ctrl-c-ctrl-c))

      (`babel-call
       (org-babel-lob-execute-maybe))

      (`statistics-cookie
       (save-excursion (org-update-statistics-cookies nil)))

      ((or `src-block `inline-src-block)
       (org-babel-execute-src-block))

      ((or `latex-fragment `latex-environment)
       (org-latex-preview))

      (`link
       (let* ((lineage (org-element-lineage context '(link) t))
              (path (org-element-property :path lineage)))
         (if (or (equal (org-element-property :type lineage) "img")
                 (and path (image-type-from-file-name path)))
             (+org--refresh-inline-images-in-subtree)
           (org-open-at-point))))

      ((guard (org-element-property :checkbox (org-element-lineage context '(item) t)))
       (let ((match (and (org-at-item-checkbox-p) (match-string 1))))
         (org-toggle-checkbox (if (equal match "[ ]") '(16)))))

      (_ (+org--refresh-inline-images-in-subtree)))))


;; I use this instead of `org-insert-item' or `org-insert-heading' which are too
;; opinionated and perform this simple task incorrectly (e.g. whitespace in the
;; wrong places).
;;;###autoload
(defun +org/insert-item-below (count)
  "Inserts a new heading, table cell or item below the current one."
  (interactive "p")
  (dotimes (_ count) (+org--insert-item 'below)))

;;
;;; Hooks

;;;###autoload
(defun +org-update-cookies-h ()
  "Update counts in headlines (aka \"cookies\")."
  (when (and buffer-file-name (file-exists-p buffer-file-name))
    (let (org-hierarchical-todo-statistics)
      ;; (org-update-parent-todo-statistics) ;; HACK: it does not work to update statistics while the below one works
      (call-interactively 'org-update-statistics-cookies))))

;;;###autoload
(defun +org-enable-auto-update-cookies-h ()
  "Update statistics cookies when saving or exiting insert mode (`evil-mode')."
  (when (bound-and-true-p evil-local-mode)
    (add-hook 'evil-insert-state-exit-hook #'+org-update-cookies-h nil t))
  (add-hook 'before-save-hook #'+org-update-cookies-h nil t))

;;;###autoload
(defun +org/remove-link ()
  "Unlink the text at point."
  (interactive)
  (unless (org-in-regexp org-link-bracket-re 1)
    (user-error "No link at point"))
  (save-excursion
    (let ((label (if (match-end 2)
                     (match-string-no-properties 2)
                   (org-link-unescape (match-string-no-properties 1)))))
      (delete-region (match-beginning 0) (match-end 0))
      (insert label))))



;; REVIEW These are all proof-of-concept. Refactor me!

;;;###autoload
(defun +org/refile-to-current-file (arg &optional file)
  "Refile current heading to elsewhere in the current buffer.
If prefix ARG, copy instead of move."
  (interactive "P")
  (let ((org-refile-targets `((,file :maxlevel . 10)))
        (org-refile-use-outline-path nil)
        (org-refile-keep arg)
        current-prefix-arg)
    (call-interactively #'org-refile)))

;;;###autoload
(defun +org/refile-to-file (arg file)
  "Refile current heading to a particular org file.
If prefix ARG, copy instead of move."
  (interactive
   (list current-prefix-arg
         (read-file-name "Select file to refile to: "
                         default-directory
                         (buffer-file-name (buffer-base-buffer))
                         t nil
                         (lambda (f) (string-match-p "\\.org$" f)))))
  (+org/refile-to-current-file arg file))

;;;###autoload
(defun +org/refile-to-other-window (arg)
  "Refile current heading to an org buffer visible in another window.
If prefix ARG, copy instead of move."
  (interactive "P")
  (let ((org-refile-keep arg)
        org-refile-targets
        current-prefix-arg)
    (dolist (win (delq (selected-window) (window-list)))
      (with-selected-window win
        (let ((file (buffer-file-name (buffer-base-buffer))))
          (and (eq major-mode 'org-mode)
               file
               (cl-pushnew (cons file (cons :maxlevel 10))
                           org-refile-targets)))))
    (call-interactively #'org-refile)))

;;;###autoload
(defun +org/refile-to-running-clock (arg)
  "Refile current heading to the currently clocked in task.
If prefix ARG, copy instead of move."
  (interactive "P")
  (unless (bound-and-true-p org-clock-current-task)
    (user-error "No active clock to refile to"))
  (let ((org-refile-keep arg))
    (org-refile 2)))

;;;###autoload
(defun +org/refile-to-last-location (arg)
  "Refile current heading to the last node you refiled to.
If prefix ARG, copy instead of move."
  (interactive "P")
  (or (assoc (plist-get org-bookmark-names-plist :last-refile)
             bookmark-alist)
      (user-error "No saved location to refile to"))
  (let ((org-refile-keep arg)
        (completing-read-function
         (lambda (_p _coll _pred _rm _ii _h default &rest _)
           default)))
    (org-refile)))

;;;###autoload
(defun +org/archive-done-tasks ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward
            (concat "\\* " (regexp-opt org-done-keywords) " ") nil t)
      (goto-char (line-beginning-position))
      (org-archive-subtree))))

(with-eval-after-load 'consult
  (defun +my/retrieval-todo-items ()
    (require 'consult-org)
    (consult--read
     (consult--with-increased-gc
      (-filter (lambda (item)
                 (not (member
                       (car (cdr (get-text-property 0 'consult-org--heading item)))
                       '("DONE" "CANCELED"))))
               (consult-org--headings nil nil 'agenda)))
     :prompt "Go to heading: "
     :category 'consult-org-heading
     :sort nil
     :require-match t
     :history '(:input consult-org--history)
     :narrow (consult-org--narrow)
     :state (consult--jump-state)
     :group
     (lambda (cand transform)
       (let ((name (buffer-name
                    (marker-buffer
                     (get-text-property 0 'consult--candidate cand)))))
         (if transform cand name)))
     :lookup #'consult--lookup-candidate))

  (defun consult-clock-in ()
    "Clock into an Org agenda heading."
    (interactive)
    (save-window-excursion
      (+my/retrieval-todo-items)
      (org-clock-in)
      (save-buffer)))
  (consult-customize consult-clock-in :prompt "Clock in: ")

  (defun consult-mark-done ()
    "Clock into an Org agenda heading."
    (interactive)
    (save-window-excursion
      (+my/retrieval-todo-items)
      (org-todo 'done)
      (save-buffer)))
  (consult-customize consult-mark-done :prompt "Mark done: ")

  )
;; OrgPac
(defvar +org-capture-file-gtd (concat +self/org-base-dir "gtd.org"))
(defvar +org-capture-file-idea (concat +self/org-base-dir "ideas.org"))
(defvar +org-capture-file-note (concat +self/org-base-dir "notes.org"))
(defvar +org-capture-file-someday (concat +self/org-base-dir "someday.org"))
(defvar +org-capture-file-done (concat +self/org-base-dir "done.org"))
(defvar +org-capture-file-goal (concat +self/org-base-dir "goals.org"))
(defvar +org-capture-file-routine (concat +self/org-base-dir "routine.org"))

(defvar +org-files (list +org-capture-file-gtd
                         +org-capture-file-someday
                         +org-capture-file-note
                         +org-capture-file-idea
                         +org-capture-file-goal
                         +org-capture-file-routine))

(use-package org
  :commands (+my/open-org-agenda)
  :hook ((org-mode . org-indent-mode)
         (org-mode . +org-enable-auto-update-cookies-h)
         (org-mode . (lambda () (show-paren-local-mode -1) (eldoc-mode -1))))
  :bind (:map org-mode-map
              ([tab] . org-cycle))
  :init
  (setq
   org-src-window-setup 'current-window
   org-element--cache-self-verify nil
   org-element-use-cache nil
   org-src-preserve-indentation nil
   org-edit-src-content-indentation 0
   org-capture-bookmark nil ;; TODO: no bookmark for refile
   org-log-done 'time
   org-hide-emphasis-markers t
   org-deadline-warning-days 90
   org-export-backends (quote (html icalendar latex md))
   org-use-speed-commands t
   org-confirm-babel-evaluate 'nil
   org-directory (expand-file-name +self/org-base-dir)
   org-ellipsis " ▼ "
   org-babel-python-command "python3"
   org-bullets-bullet-list '("#")

   org-indirect-buffer-display 'current-window
   ;; org-eldoc-breadcrumb-separator " → "
   org-enforce-todo-dependencies t
   org-entities-user
   '(("flat"  "\\flat" nil "" "" "266D" "♭")
     ("sharp" "\\sharp" nil "" "" "266F" "♯"))
   org-fontify-done-headline t
   org-fontify-quote-and-verse-blocks t
   org-fontify-whole-heading-line t
   org-footnote-auto-label 'plain
   org-hide-leading-stars t
   org-hide-leading-stars-before-indent-mode t
   org-image-actual-width nil
   org-list-description-max-indent 4
   org-priority-faces
   '((?A . error)
     (?B . warning)
     (?C . success))
   org-startup-indented t
   org-use-sub-superscripts '{}
   )

  :config
  (setq org-modules '())

  ;; babel
  (defun my/org-babel-execute-src-block (&optional _arg info _params)
    "Load language if needed"
    (let* ((lang (nth 0 info))
           (sym (if (member (downcase lang) '("c" "cpp" "c++")) 'C (intern lang)))
           (backup-languages org-babel-load-languages)
           (pair (assoc sym backup-languages)))
      ;; - `(LANG . nil)' 是有意义的，不宜覆盖，详见 `org-babel-do-load-languages'。
      ;; - 只加载当前语言，「按需」到底。
      (unwind-protect
          (org-babel-do-load-languages 'org-babel-load-languages (list (cons sym t)))
        (setq-default org-babel-load-languages
                      (if pair
                          backup-languages
                        (append (list (cons sym t)) backup-languages))))))
  (advice-add 'org-babel-execute-src-block :before #'my/org-babel-execute-src-block )

  ;; ui
  ;; (set-face-attribute 'org-table nil :family "Sarasa Mono SC" :weight 'semi-bold)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (add-hook 'org-capture-mode-hook #'evil-insert-state)

  (custom-set-faces
   '(org-done ((t (:strike-through t :foreground "gray"))))
   '(org-headline-done ((t (:strike-through t :foreground "gray")))))

  (defface org-checkbox-done-text
    '((t (:strike-through t)))
    "Face for the text part of a checked org-mode checkbox.")
  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
      1 'org-checkbox-done-text prepend))
   'append)

  ;; log
  (setq org-log-into-drawer "LOGBOOK")
  (setq org-log-into-drawer t)

  ;; misc
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-targets '((+org-capture-file-gtd :level . 3)
                             (+org-capture-file-someday :level . 3)))
  (setq org-tag-alist '(("lab" . ?L) ("academic" . ?a) ("life" . ?l) ("emacs" . ?e)
                        ("habit" . ?h) ("ACT_MONTH" . ?m) ("ACT_WEEK" . ?w)))
  (setq org-capture-templates
        '(("t" "Todo" entry
           (file +org-capture-file-gtd)
           "* TODO %i%? \n:LOGBOOK: \n:CREATED: %U \n:END:" :prepend t :kill-buffer t)
          ("w" "Watting for" entry
           (file +org-capture-file-gtd)
           "* WAITING %?\n%i" :prepend t :kill-buffer t)
          ("n" "Note" entry
           (file+headline +org-capture-file-note "Notes")
           "* %u %?\n%i" :prepend t :kill-buffer t)
          ("s" "Someday maybe" entry
           (file +org-capture-file-someday)
           "* %?\n%i" :prepend t :kill-buffer t)
          ("i" "Idea" entry
           (file+headline +org-capture-file-idea "Ideas")
           "* %u %?\n%i" :prepend t :kill-buffer t)
          ))
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"  ; A task that needs doing & is ready to do
           "PROJ(p)"  ; An ongoing project that cannot be completed in one step
           "INPROCESS(i)"  ; A task that is in progress
           "WAITING(w)"  ; Something is holding up this task; or it is paused
           "|"
           "DONE(d)"  ; Task successfully completed
           "CANCELED(c)") ; Task was cancelled, aborted or is no longer applicable
          ))

  ;; https://emacs-china.org/t/topic/2119/15
  (defun my--diary-chinese-anniversary (lunar-month lunar-day &optional year mark)
    (require 'cal-china)
    (if year
        (let* ((d-date (diary-make-date lunar-month lunar-day year))
               (a-date (calendar-absolute-from-gregorian d-date))
               (c-date (calendar-chinese-from-absolute a-date))
               (cycle (car c-date))
               (yy (cadr c-date))
               (y (+ (* 100 cycle) yy)))
          (diary-chinese-anniversary lunar-month lunar-day y mark))
      (diary-chinese-anniversary lunar-month lunar-day year mark)))

  ;; binding
  (with-eval-after-load 'general
    (general-define-key :states '(normal insert)
                        :keymaps 'org-mode-map
                        "C-<return>" #'+org/insert-item-below
                        "C-S-<return>" 'org-insert-subheading
                        )
    (general-define-key :states '(normal)
                        :keymaps 'org-mode-map
                        "<return>" #'+org/dwim-at-point)

    (local-leader-def
      :keymaps 'org-mode-map
      "'" 'org-edit-special
      "*" 'org-ctrl-c-star
      "+" 'org-ctrl-c-minus
      "," 'org-switchb
      ;; "." 'org-goto

      "." 'consult-org-heading

      "A" 'org-archive-subtree
      "e" 'org-export-dispatch
      "f" 'org-set-property
      "I" 'org-toggle-inline-images
      "q" 'org-set-tags-command
      "t" 'org-todo
      "T" 'org-todo-list
      "x" 'org-toggle-checkbox

      "a" '(:wk "attackments")
      "aa" 'org-attach
      "ad" 'org-attach-delete-one
      "aD" 'org-attach-delete-all
      "an" 'org-attach-new
      "ao" 'org-attach-open
      "aO" 'org-attach-open-in-emacs
      "ar" 'org-attach-reveal
      "aR" 'org-attach-reveal-in-emacs
      "au" 'org-attach-url
      "as" 'org-attach-set-directory
      "aS" 'org-attach-sync

      "b"  '(:wk "tables")
      "b-" 'org-table-insert-hline
      "ba" 'org-table-align
      "bb" 'org-table-blank-field
      "bc" 'org-table-create-or-convert-from-region
      "be" 'org-table-edit-field
      "bf" 'org-table-edit-formulas
      "bh" 'org-table-field-info
      "bs" 'org-table-sort-lines
      "br" 'org-table-recalculate
      "bR" 'org-table-recalculate-buffer-tables
      "bd" '(:wk "delete")
      "bdc" 'org-table-delete-column
      "bdr" 'org-table-kill-row
      "bi" '(:wk "insert")
      "bic" 'org-table-insert-column
      "bih" 'org-table-insert-hline
      "bir" 'org-table-insert-row
      "biH" 'org-table-hline-and-move
      "bt" '("toggle")
      "btf" 'org-table-toggle-formula-debugger
      "bto" 'org-table-toggle-coordinate-overlays

      "c" '(:wk "clock")
      "cc" 'org-clock-cancel
      "cd" 'org-clock-mark-default-task
      "ce" 'org-clock-modify-effort-estimate
      "cE" 'org-set-effort
      "cg" 'org-clock-goto
      "ci" 'org-clock-in
      "cI" 'org-clock-in-last
      "co" 'org-clock-out
      "cr" 'org-resolve-clocks
      "cR" 'org-clock-report
      "ct" 'org-evaluate-time-range
      "c=" 'org-clock-timestamps-up
      "c-" 'org-clock-timestamps-down

      "d" '(:wk "date/deadline")
      "dd" 'org-deadline
      "ds" 'org-schedule
      "dt" 'org-time-stamp
      "dT" 'org-time-stamp-inactive

      "D" '+my-org/mark-done

      "g" '(:wk "goto")
      "gc" 'org-clock-goto
      "gi" 'org-id-goto
      "gr" 'org-refile-goto-last-stored
      "gx" 'org-capture-goto-last-stored

      "l" '(:wk "links")
      "lc" 'org-cliplink
      "ld" '+org/remove-link
      "li" 'org-id-store-link
      "ll" 'org-insert-link
      "lL" 'org-insert-all-links
      "ls" 'org-store-link
      "lS" 'org-insert-last-stored-link
      "lt" 'org-toggle-link-display

      "P" '(:wk "publish")
      "Pa" 'org-publish-all
      "Pf" 'org-publish-current-file
      "Pp" 'org-publish
      "PP" 'org-publish-current-project
      "Ps" 'org-publish-sitemap

      "r" '(:wk "refile")
      "r." '+org/refile-to-current-file
      "rc" '+org/refile-to-running-clock
      "rl" '+org/refile-to-last-location
      "rf" '+org/refile-to-file
      "ro" '+org/refile-to-other-window
      "rr" 'org-refile

      "s" '(:wk "tree/subtree")
      "sa" 'org-toggle-archive-tag
      "sb" 'org-tree-to-indirect-buffer
      "sd" 'org-cut-subtree
      "sh" 'org-promote-subtree
      "sj" 'org-move-subtree-down
      "sk" 'org-move-subtree-up
      "sl" 'org-demote-subtree
      "sn" 'org-narrow-to-subtree
      "sr" 'org-refile
      "ss" 'org-sparse-tree
      "sA" 'org-archive-subtree
      "sN" 'widen
      "sS" 'org-sort

      "p" '(:wk "priority")
      "pd" 'org-priority-down
      "pp" 'org-priority
      "pu" 'org-priority-up

      "z" '(:wk "Download")
      "zc" 'org-download-clipboard
      "zd" 'org-download-delete
      "zi" 'org-download-image
      "zy" 'org-download-yank
      "ze" 'org-download-edit
      "zr" 'org-download-rename-at-point
      "zR" 'org-download-rename-last-file
      "zs" 'org-download-screenshot
      )
    )

  ;; functions
;;;###autoload
  (defun +my/open-org-agenda ()
    "open org agenda in left window"
    (interactive)
    (org-agenda nil "n")
    (kill-buffer "done.org")
    (kill-buffer "goals.org")
    (kill-buffer "routine.org"))
  (defun +my-org/mark-done ()
    (interactive)
    (when (derived-mode-p 'org-mode)
      (org-back-to-heading)
      (when-let* ((close-time (org-entry-get (point) "CLOSED"))
                  (close-time (org-time-string-to-time close-time))
                  (close-time (decode-time close-time))
                  (close-time (list (decoded-time-month close-time) (decoded-time-day close-time) (decoded-time-year close-time))))
        (org-cut-subtree)
        (with-current-buffer (find-file-noselect +org-capture-file-done)
          (org-datetree-find-iso-week-create close-time)
          (org-paste-subtree)
          (org-next-visible-heading 1)
          (when (and (null (nth 2 (org-heading-components)))
                     (= (nth 0 (org-heading-components)) 3))
            (org-cut-subtree))
          (save-buffer)
          (kill-buffer)))))

;;;###autoload
  (defun org-clock-merge (arg)
    "Merge the org CLOCK line with the next CLOCK line.

Requires that the time ranges in two lines overlap, i.e. the
start time of the first line and the second time of the second
line are identical.

If the testing fails, move the cursor one line down.

Universal argument ARG overrides the test and merges
the lines even if the ranges do not overlap."

    (interactive "P")
    (let* ((org-clock-regexp (concat "CLOCK: " org-ts-regexp3 "--" org-ts-regexp3))
           (first-line-start (line-beginning-position))
           (first-line (buffer-substring
                        (line-beginning-position) (line-end-position)))
           (first-line-t1 (if (string-match org-clock-regexp first-line)
                              (match-string 1 first-line)
                            (progn
                              (forward-line)
                              (user-error "The first line must have a valid CLOCK range"))))
           (first-line-t2 (match-string 9 first-line))
           (second-line (progn
                          (forward-line)
                          (buffer-substring
                           (line-beginning-position) (line-end-position))))
           (second-line-t1 (if (string-match org-clock-regexp second-line)
                               (match-string 1 second-line)
                             (user-error "The second line must have a valid CLOCK range")))
           (second-line-t2 (match-string 9 second-line)))

      ;; check if lines should be merged
      (unless (or arg (equal first-line-t1 second-line-t2))
        (user-error "Clock ranges not continuous. Override with universal argument"))

      ;; remove the two lines
      (delete-region first-line-start (line-end-position))
      ;; indent
      (org-cycle)
      ;; insert new time range
      (insert (concat "CLOCK: [" second-line-t1 "]--[" first-line-t2 "]"))
      ;; generate duration
      (org-ctrl-c-ctrl-c)))

  (use-package org-agenda
    :straight nil
    :ensure nil
    :bind
    (:map org-agenda-mode-map
          ("q" . winner-undo))
    :init
    (setq org-agenda-files (list +org-capture-file-gtd
                                 +org-capture-file-done
                                 +org-capture-file-routine)

          org-agenda-window-setup 'only-window
          org-agenda-span 3
          org-agenda-start-with-log-mode t
          org-agenda-start-with-clockreport-mode nil
          org-agenda-start-on-weekday 1
          org-agenda-todo-ignore-scheduled 'future
          )
    :config
    (plist-put org-agenda-clockreport-parameter-plist :maxlevel 3)
    (setq org-agenda-custom-commands
          '(("n" "Agenda"
             ((tags-todo
	           "ACT_WEEK"
	           ((org-agenda-files (list +org-capture-file-goal))
	            (org-agenda-overriding-header "Goals for this week")))
              (tags-todo
	           "ACT_MONTH"
	           ((org-agenda-files (list +org-capture-file-goal))
	            (org-agenda-overriding-header "Goals for this month")))
	          (agenda)
              (alltodo "")))))
    (evil-set-initial-state 'org-agenda-mode 'motion)
    (setq-default
     org-agenda-inhibit-startup nil
     org-agenda-skip-unavailable-files t)
    (with-eval-after-load 'general
      (local-leader-def
        :keymaps 'org-agenda-mode-map
        "d" '(:wk "date/deadline")
        "dd" 'org-agenda-deadline
        "ds" 'org-agenda-schedule

        "c" '(:wk "clock")
        "cc" 'org-agenda-clock-cancel
        "cg" 'org-agenda-clock-goto
        "ci" 'org-agenda-clock-in
        "co" 'org-agenda-clock-out
        "cr" 'org-agenda-clockreport-mode
        "cs" 'org-agenda-show-clocking-issues

        "p" '(:wk "priority")
        "pd" 'org-agenda-priority-down
        "pp" 'org-agenda-priority
        "pu" 'org-agenda-priority-up

        "q" 'org-agenda-set-tags
        "r" 'org-agenda-refile
        "t" 'org-agenda-todo)
      )

    (run-with-timer 15 nil
                    (lambda ()
                      (with-eval-after-load 'org
                        (require 'appt)

                        (setq appt-display-interval '5) ;; warn every 5 minutes from t - appt-message-warning-time
                        (setq
                         appt-message-warning-time '15 ;; send first warning 15 minutes before appointment
                         appt-display-mode-line nil ;; don't show in the modeline
                         appt-display-format 'window) ;; pass warnings to the designated window function
                        (setq appt-disp-window-function (function ct/appt-display-native))

                        (appt-activate 1) ;; activate appointment notification

                        ;; brew install terminal-notifier
                        (defun ct/send-notification (title msg)
                          (let ((notifier-path (executable-find "terminal-notifier")))
                            (start-process
                             "Appointment Alert"
                             nil
                             notifier-path
                             "-message" msg
                             "-title" title
                             "-sender" "org.gnu.Emacs"
                             "-activate" "org.gnu.Emacs")))
                        (defun ct/appt-display-native (min-to-app new-time msg)
                          (ct/send-notification
                           (format "Appointment in %s minutes" min-to-app) ; Title
                           (format "%s" msg))) ; Message/detail text
                        ;; Agenda-to-appointent hooks
                        (run-at-time nil 900
                                     (lambda ()
                                       (setq appt-time-msg-list nil)
                                       (org-agenda-to-appt)))
                        (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view
                        )))
    )
  )
;; ;; -OrgPac

(use-package org-download
  :commands (org-download-clipboard org-download-delete org-download-image org-download-yank org-download-edit org-download-rename-at-point org-download-rename-last-file org-download-screenshot)
  :after org
  :custom
  (org-download-image-dir "img/")
  (org-download-heading-lvl nil)
  :config
  (cond (*sys/mac*
         (setq org-download-screenshot-method "screencapture -i %s"))))

(use-package org-contrib
  :after org)

(use-package org-habit
  :straight nil
  :after org)

(use-package calfw
  :commands (cfw:open-org-calendar cfw:open-org-week-calendar)
  :straight (calfw :includes (calfw-org calfw-cal) :host github :repo "zemaye/emacs-calfw" :files ("*.el"))
  :bind (:map cfw:calendar-mode-map
              ("s" . cfw:show-details-command))
  :custom
  (cfw:display-calendar-holidays nil)
  :config
  (require 'calfw-org)
  (defun cfw:open-org-week-calendar ()
    "Open an org schedule calendar in the new buffer."
    (interactive)
    (save-excursion
      (let* ((source1 (cfw:org-create-source))
             (curr-keymap (if cfw:org-overwrite-default-keybinding cfw:org-custom-map cfw:org-schedule-map))
             (cp (cfw:create-calendar-component-buffer
                  :view 'week
                  :contents-sources (list source1)
                  :custom-map curr-keymap
                  :sorter 'cfw:org-schedule-sorter)))
        (switch-to-buffer (cfw:cp-get-buffer cp))
        (when (not org-todo-keywords-for-agenda)
          (message "Warn : open org-agenda buffer first."))))))

(use-package org-pomodoro
  :after org
  :commands org-pomodoro
  :config
  (setq alert-default-style 'notifier)

  (defun org-pomodoro (&optional arg)
    "Start a new pomodoro or stop the current one.
When no timer is running for `org-pomodoro` a new pomodoro is started and
the current task is clocked in.  Otherwise EMACS will ask whether we´d like to
kill the current timer, this may be a break or a running pomodoro."
    (interactive "P")

    (when (and org-pomodoro-last-clock-in
               org-pomodoro-expiry-time
               (org-pomodoro-expires-p)
               (y-or-n-p "Reset pomodoro count? "))
      (setq org-pomodoro-count 0))
    (setq org-pomodoro-last-clock-in (current-time))

    (cond
     ;; possibly break from overtime
     ((and (org-pomodoro-active-p) (eq org-pomodoro-state :overtime))
      (org-pomodoro-finished))
     ;; Maybe kill running pomodoro
     ((org-pomodoro-active-p)
      (if (or (not org-pomodoro-ask-upon-killing)
              (y-or-n-p "There is already a running timer.  Would you like to stop it? "))
          (org-pomodoro-kill)
        (message "Alright, keep up the good work!")))
     ;; or start and clock in pomodoro
     (t
      (cond
       ((equal arg '(4))
        (let ((current-prefix-arg '(4)))
          (call-interactively 'org-clock-in)))
       ((equal arg '(16))
        (call-interactively 'org-clock-in-last))
       ((memq major-mode (list 'org-mode 'org-journal-mode))
        (call-interactively 'org-clock-in))
       ((eq major-mode 'org-agenda-mode)
        (org-with-point-at (org-get-at-bol 'org-hd-marker)
          (call-interactively 'org-clock-in)))
       (t (let ((current-prefix-arg '(4)))
            (call-interactively 'consult-clock-in))))
      (org-pomodoro-start :pomodoro))))
  )
#+end_src
*** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :defer t
  :mode ("\\.md\\'" . markdown-mode))

#+end_src
* Edit
** Fold
#+begin_src emacs-lisp
;; Used for fold
;; Copy from doom-emacs
;;
;;; Helpers

(defun +fold--ensure-hideshow-mode ()
  (unless (bound-and-true-p hs-minor-mode)
    (hs-minor-mode +1)))

(defun +fold--vimish-fold-p ()
  (and (featurep 'vimish-fold)
       (cl-some #'vimish-fold--vimish-overlay-p
                (overlays-at (point)))))

(defun +fold--outline-fold-p ()
  (and (or (bound-and-true-p outline-minor-mode)
           (derived-mode-p 'outline-mode))
       (outline-on-heading-p)))

(defun +fold--hideshow-fold-p ()
  (+fold--ensure-hideshow-mode)
  (save-excursion
    (ignore-errors
      (or (hs-looking-at-block-start-p)
          (hs-find-block-beginning)
          (unless (eolp)
            (end-of-line)
            (+fold--hideshow-fold-p))))))

(defun +fold--invisible-points (count)
  (let (points)
    (save-excursion
      (catch 'abort
        (if (< count 0) (beginning-of-line))
        (while (re-search-forward hs-block-start-regexp nil t
                                  (if (> count 0) 1 -1))
          (unless (invisible-p (point))
            (end-of-line)
            (when (hs-already-hidden-p)
              (push (point) points)
              (when (>= (length points) count)
                (throw 'abort nil))))
          (forward-line (if (> count 0) 1 -1)))))
    points))

(defmacro +fold-from-eol (&rest body)
  "Perform action after moving to the end of the line."
  `(save-excursion
     (end-of-line)
     ,@body))


;;
;;; Commands

;;;###autoload
(defun +fold/toggle ()
  "Toggle the fold at point.

Targets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds."
  (interactive)
  (save-excursion
    (cond ((+fold--vimish-fold-p) (vimish-fold-toggle))
          ((+fold--outline-fold-p)
           (cl-letf (((symbol-function #'outline-hide-subtree)
                      (symbol-function #'outline-hide-entry)))
             (outline-toggle-children)))
          ((+fold--hideshow-fold-p) (+fold-from-eol (hs-toggle-hiding))))))

;;;###autoload
(defun +fold/open ()
  "Open the folded region at point.

Targets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds."
  (interactive)
  (save-excursion
    (cond ((+fold--vimish-fold-p) (vimish-fold-unfold))
          ((+fold--outline-fold-p)
           (outline-show-children)
           (outline-show-entry))
          ((+fold--hideshow-fold-p) (+fold-from-eol (hs-show-block))))))

;;;###autoload
(defun +fold/close ()
  "Close the folded region at point.

Targets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds."
  (interactive)
  (save-excursion
    (cond ((+fold--vimish-fold-p) (vimish-fold-refold))
          ((+fold--hideshow-fold-p) (+fold-from-eol (hs-hide-block)))
          ((+fold--outline-fold-p) (outline-hide-subtree)))))

;;;###autoload
(defun +fold/open-all (&optional level)
  "Open folds at LEVEL (or all folds if LEVEL is nil)."
  (interactive
   (list (if current-prefix-arg (prefix-numeric-value current-prefix-arg))))
  (cond ((featurep 'vimish-fold)
         (vimish-fold-unfold-all))
        ((save-excursion
           (+fold--ensure-hideshow-mode)
           (if (integerp level)
               (progn
                 (outline-hide-sublevels (max 1 (1- level)))
                 (hs-life-goes-on
                  (hs-hide-level-recursive (1- level) (point-min) (point-max))))
             (hs-show-all)
             (when (fboundp 'outline-show-all)
               (outline-show-all)))))))

;;;###autoload
(defun +fold/close-all (&optional level)
  "Close folds at LEVEL (or all folds if LEVEL is nil)."
  (interactive
   (list (if current-prefix-arg (prefix-numeric-value current-prefix-arg))))
  (save-excursion
    (progn
      (when (featurep 'vimish-fold)
        (vimish-fold-refold-all))
      (+fold--ensure-hideshow-mode)
      (hs-life-goes-on
       (if (integerp level)
           (hs-hide-level-recursive (1- level) (point-min) (point-max))
         (hs-hide-all))))))

;;;###autoload
(defun +fold/next (count)
  "Jump to the next vimish fold, outline heading or folded region."
  (interactive "p")
  (cl-loop with orig-pt = (point)
           for fn
           in (list (lambda ()
                      (when (bound-and-true-p hs-block-start-regexp)
                        (car (+fold--invisible-points count))))
                    (lambda ()
                      (when (featurep 'vimish-fold)
                        (if (> count 0)
                            (evil-vimish-fold/next-fold count)
                          (evil-vimish-fold/previous-fold (- count))))
                      (if (/= (point) orig-pt) (point))))
           if (save-excursion (funcall fn))
           collect it into points
           finally do
           (if-let* ((pt (car (sort points (if (> count 0) #'< #'>)))))
               (goto-char pt)
             (message "No more folds %s point" (if (> count 0) "after" "before"))
             (goto-char orig-pt))))

;;;###autoload
(defun +fold/previous (count)
  "Jump to the previous vimish fold, outline heading or folded region."
  (interactive "p")
  (+fold/next (- count)))

(defface +fold-hideshow-folded-face
  `((t (:inherit font-lock-comment-face :weight light)))
  "Face to hightlight `hideshow' overlays."
  :group 'doom-themes)

;;;###autoload
(defun +fold-hideshow-forward-block-by-indent-fn (_arg)
  (let ((start (current-indentation)))
    (forward-line)
    (unless (= start (current-indentation))
      (let ((range (+fold-hideshow-indent-range)))
        (goto-char (cadr range))
        (end-of-line)))))

;;
;;; Indentation detection

(defun +fold--hideshow-empty-line-p (_)
  (string= "" (string-trim (thing-at-point 'line 'no-props))))

(defun +fold--hideshow-geq-or-empty-p (base-indent)
  (or (+fold--hideshow-empty-line-p base-indent)
      (>= (current-indentation) base-indent)))

(defun +fold--hideshow-g-or-empty-p (base-indent)
  (or (+fold--hideshow-empty-line-p base-indent)
      (> (current-indentation) base-indent)))

(defun +fold--hideshow-seek (start direction before skip predicate base-indent)
  "Seeks forward (if direction is 1) or backward (if direction is -1) from start, until predicate
fails. If before is nil, it will return the first line where predicate fails, otherwise it returns
the last line where predicate holds."
  (save-excursion
    (goto-char start)
    (goto-char (point-at-bol))
    (let ((bnd (if (> 0 direction)
                   (point-min)
                 (point-max)))
          (pt (point)))
      (when skip (forward-line direction))
      (cl-loop while (and (/= (point) bnd) (funcall predicate base-indent))
               do (progn
                    (when before (setq pt (point-at-bol)))
                    (forward-line direction)
                    (unless before (setq pt (point-at-bol)))))
      pt)))

(defun +fold-hideshow-indent-range (&optional point)
  "Return the point at the begin and end of the text block with the same (or
greater) indentation. If `point' is supplied and non-nil it will return the
begin and end of the block surrounding point."
  (save-excursion
    (when point
      (goto-char point))
    (let ((base-indent (current-indentation))
          (begin (point))
          (end (point)))
      (setq begin (+fold--hideshow-seek begin -1 t nil #'+fold--hideshow-geq-or-empty-p base-indent)
            begin (+fold--hideshow-seek begin 1 nil nil #'+fold--hideshow-g-or-empty-p base-indent)
            end   (+fold--hideshow-seek end 1 t nil #'+fold--hideshow-geq-or-empty-p base-indent)
            end   (+fold--hideshow-seek end -1 nil nil #'+fold--hideshow-empty-line-p base-indent))
      (list begin end base-indent))))


(use-package hideshow
  :config
  (setq hs-special-modes-alist
        (append
         '((yaml-ts-mode "\\s-*\\_<\\(?:[^:]+\\)\\_>"
                      ""
                      "#"
                      +fold-hideshow-forward-block-by-indent-fn nil)
           (latex-mode
            ;; LaTeX-find-matching-end needs to be inside the env
            ("\\\\begin{[a-zA-Z*]+}\\(\\)" 1)
            "\\\\end{[a-zA-Z*]+}"
            "%"
            (lambda (_arg)
              ;; Don't fold whole document, that's useless
              (unless (save-excursion
                        (search-backward "\\begin{document}"
                                         (line-beginning-position) t))
                (LaTeX-find-matching-end)))
            nil))
         hs-special-modes-alist
         '((t)))))
(use-package vimish-fold)
(use-package evil-vimish-fold
  :after evil
  :bind
  (([remap evil-toggle-fold]   . #'+fold/toggle)
   ([remap evil-close-fold]    . #'+fold/close)
   ([remap evil-open-fold]     . #'+fold/open)
   ([remap evil-open-fold-rec] . #'+fold/open)
   ([remap evil-close-folds]   . #'+fold/close-all)
   ([remap evil-open-folds]    . #'+fold/open-all))
  :commands (evil-vimish-fold/next-fold evil-vimish-fold/previous-fold
                                        evil-vimish-fold/delete evil-vimish-fold/delete-all
                                        evil-vimish-fold/create evil-vimish-fold/create-line)
  :config
  (vimish-fold-global-mode +1))
;; end of fold
#+end_src
* Binding
#+begin_src emacs-lisp
(use-package which-key
  :hook (+my/first-input . which-key-mode)

  :custom
  (which-key-separator " ")
  (which-key-prefix-prefix "+"))

;; Leader def
(use-package general
  :after evil
  :demand t
  :config
  (general-create-definer tab-def
    :states '(normal visual emacs motion)
    :keymaps 'override
    :prefix "C-s"
    )

  (tab-def
    "" nil
    "c" '(tab-new :wk "New")
    "r" '(tab-bar-rename-tab :wk "Rename")
    "d" '(tab-bar-close-tab :wk "Close")
    "s" '(tab-bar-select-tab-by-name :wk "Select")
    "t" '(+my/smart-switch-to-vterm-tab :wk "Vterm")
    "1" '((lambda () (interactive) (tab-bar-select-tab 1)) :wk "Select 1")
    "2" '((lambda () (interactive) (tab-bar-select-tab 2)) :wk "Select 2")
    "3" '((lambda () (interactive) (tab-bar-select-tab 3)) :wk "Select 3")
    "4" '((lambda () (interactive) (tab-bar-select-tab 4)) :wk "Select 4")
    "5" '((lambda () (interactive) (tab-bar-select-tab 5)) :wk "Select 5")
   )

  (general-create-definer leader-def
    :states '(normal visual emacs motion)
    :keymaps 'override
    :prefix "SPC"
    )
  (general-create-definer local-leader-def
    :states '(normal visual emacs motion)
    :keymaps 'override
    :prefix ",")

  (local-leader-def
    "w" 'evil-avy-goto-word-1
    "/" 'evilnc-comment-or-uncomment-lines)

  (general-evil-define-key 'normal
    '(python-mode-map LaTeX-mode-map emacs-lisp-mode-map yaml-ts-mode-map)
    "<tab>" '+fold/toggle)

  ;; evil mode
  (general-def 'normal
    "/" '+my/consult-line
    "?" '+my/consult-line-symbol-at-point
    "gd" 'xref-find-definitions
    "gr" 'xref-find-references)

  ;; Navigation
  (general-def 'insert
    "C-a" 'beginning-of-line
    "C-e" 'end-of-line)

  (general-def 'insert
    "C-o" 'evil-normal-state)

  (general-def "<escape>" 'keyboard-quit)
  (general-def "C-<tab>" 'tab-next)

  (leader-def
    "" nil
    ;; "<SPC>" '(execute-extended-command :wk "M-x")
    "<SPC>" '(switch-to-buffer :wk "Switch buffer") ;; maybe `switch-to-buffer' is used more frequently
    "/" '((lambda() (interactive) (consult-ripgrep default-directory)) :wk "Search here")
    "?" '(+consult-ripgrep-at-point :wk "Search symbol here")
    "." '(find-file :wk "Find file")
    ";" '(pp-eval-expression :wk "Evil expression")
    ":" '(+my/open-org-agenda :wk "Agenda")
    "x" '(org-capture :wk "Org capture")
    "r" '(er/expand-region :wk "expand-region")
    "k" '(+my/replace :wk "Replace") ;;  FIXME: more semantic key

    "b" '(:wk "Buffer")
    "b[" '(previous-buffer :wk "Previous buffer")
    "b]" '(next-buffer :wk "Next buffer")
    "bb" '(switch-to-buffer :wk "Switch buffer")
    "bk" '(kill-current-buffer :wk "Kill buffer")
    "bd" '((lambda () (interactive) (kill-current-buffer) (evil-quit)) :wk "Kill and close")
    "bq" '(evil-quit :wk "evil-quit")
    "bK" '(+my/kill-other-buffers :wk "Kill other buffers")
    "bs" '(basic-save-buffer :wk "Save buffer")
    "bS" '(evil-write-all :wk "Save all buffer")

    "f" '(:wk "Files")
    "ff" '(find-file :wk "Find file")
    "fr" '(+my/open-recent :wk "Recent file")
    "fs" '(+my/save-file :wk "Save file")
    "fd" '(dired-jump :wk "Current directory")
    "fe" '((lambda() (interactive)(find-file "~/.emacs.d/init.org")) :wk "init.org")
    "fo" '((lambda() (interactive)(find-file (completing-read "Open org files:" +org-files))) :wk "Org files")
    "fh" '((lambda() (interactive)(consult-fd default-directory)) :wk "Find file here")
    "fH" '((lambda() (interactive)(find-file (read-file-name "Remote: " "/scp:"))) :wk "Remote")

    "z" '(consult-dir :wk "z.lua")

    "fE" '(:wk "File Encoding")
    "fEr" '(revert-buffer-with-coding-system :wk "Revert encoding")
    "fEs" '(set-buffer-file-coding-system :wk "Set encoding")

    "j" '(:wk "Jump")
    "jj" '(evil-avy-goto-char :wk "Jump to character")
    "jl" '(evil-avy-goto-line :wk "Jump to line")
    "je" '(+vertico/jump-list :wk "Jump-list")

    "s" '(:wk "Search")
    "sb" '(+my/consult-line-symbol-at-point :wk "Search buffer")
    "si" '(+my/imenu :wk "Jump to symbol")
    "sp" '(consult-ripgrep :wk "Search project")
    "sT" '(load-theme :wk "Load theme")
    "sh" '((lambda() (interactive) (consult-ripgrep default-directory)) :wk "Search here")
    "sd" '(devdocs-lookup-at-point :wk "Search devdocs")
    "sD" '(devdocs-search-at-point :wk "Search devdocs")
    "sg" '(+my/google-it :wk "Google")

    "c" '(:wk "Code")
    "cf" '(format-all-buffer :wk "Format buffer")
    "cw" '(delete-trailing-whitespace :wk "Delete trailing whitespace")
    "cm" '(symbol-overlay-put :wk "Mark")

    "e" '(:wk "Error")
    "es" '(flymake-start :wk "Check current buffer")
    "el" '(consult-flymake :wk "List errors")
    "eP" '(flymake-show-project-diagnostics :wk "Show project errors")
    "eb" '(flymake-show-buffer-diagnostics :wk "Show buffer errors")
    "en" '(flymake-goto-next-error :wk "Next error")
    "ep" '(flymake-goto-prev-error :wk "Previous error")


    "g" '(:wk "Git")
    "gs" '(magit-status :wk "status")
    "ga" '(magit-stage-file :wk "stage file")
    "gp" '(magit-push :wk "push")
    "gc" '(magit-commit :wk "commit")
    ;; "gu" '((lambda() (interactive)(progn (call-interactively 'magit-stage-file) (call-interactively 'magit-commit))) :wk "stage and commit")
    "gu" '(aborn/simple-git-commit-push :wk "stage and commit")
    "gb" '(magit-branch-checkout :wk "checkout")
    "gB" '(magit-blame :wk "blame")
    "gf" '(magit-fetch :wk "fetch")
    "gF" '(magit-pull :wk "pull")
    "gl" '(magit-log :wk "log")
    "go" '(magit-open-repo :wk "open repo")
    "gm" '(gitmoji-picker :wk "open repo")

    "w" '(:wk "Window")
    ;; :sp
    "-" '(evil-window-split :wk "Split window vertically")
    ;; :vsp
    "\\" '(evil-window-vsplit :wk "Split window horizontally")
    "wj" '(evil-window-down :wk "Focus window down")
    "wk" '(evil-window-up :wk "Focus window up")
    "wh" '(evil-window-left :wk "Focus window left")
    "wl" '(evil-window-right :wk "Focus window right")
    "w=" '(balance-windows :wk "balance windows")
    "wu" '(winner-undo :wk "Undo window")
    "wr" '(winner-redo :wk "Redo window")
    "ws" '(ace-window :wk "Select window")
    "wo" '(delete-other-windows :wk "Maximize window")

    "t" '(:wk "Toggle")
    "tl" '(toggle-truncate-lines :wk "Line wrap")
    "td" '(toggle-debug-on-error :wk "Debug on error")
    "tt" '(dirvish :wk "Dirvish")
    "ts" '(dirvish-side :wk "Dirvish side")
    "te" '(vterm-posframe-toggle :wk "Shell")
    "tc" '(olivetti-mode :wk "Center")
    "ti" '(toggle-indent :wk "Indent")
    "tp" '(+my/profiler-toggle :wk "Profiler")
    "tb" '(blamer-mode :wk "Blame")

    "o" '(:wk "Open")
    "om" '((lambda () (interactive) (mu4e)) :wk "Mail")
    "oy" '(+my/youdao-search-at-point :wk "Youdao")
    "oY" '(youdao-dictionary-search-from-input :wk "Youdao from input")
    "oe" '((lambda() (interactive)(if (get-buffer "vterm") (switch-to-buffer "vterm") (call-interactively #'vterm))) :wk "Shell")
    "ov" '(vterm-other-window :wk "Shell in window")
    "ot" '(org-todo-list :wk "Org Todo")
    "ox" '(org-agenda :wk "Org agenda")
    "ob" '(ebib :wk "Ebib")
    "oB" '(ebib-import-ref :wk "Ebib import")
    "oc" '(cfw:open-org-week-calendar :wk "Week calendar")
    "oC" '(cfw:open-org-calendar :wk "Calendar")
    "od" '(consult-mark-done :wk "Mark done")
    "oi" '(consult-clock-in :wk "Clock in")
    "oo" '((lambda () (interactive)(org-clock-out) (org-save-all-org-buffers)) :wk "Clock out")
    "op" '(org-pomodoro :wk "Pomodoro")
    "ou" '(browse-url :wk "Url")
    "y" '(multi-translate-yank-at-point :wk "Yank translate") ;;  FIXME: for thesis
    "Y" '(multi-translate-yank-at-point-and-paste-to-right :wk "Yank translate and paste") ;;  FIXME: for thesis

    "p" '(:wk "Project")
    "pp" '(project-switch-project :wk "Switch project")
    "pf" '(consult-project-extra-find :wk "Find file in project")
    "pt" '(magit-todos-list :wk "List project tasks")
    "pk" '(project-kill-buffers :wk "Kill project buffers")

    "q" '(:wk "Quit")
    ;; "qq" '(kill-emacs :wk "Quit")
    "qq" '(save-buffers-kill-terminal :wk "Quit")
    "qr" '(restart-emacs :wk "Restart")

    "u" '((lambda() (interactive)(call-process-shell-command "rc" nil 0)) :wk "Sync code")
    )
  )
#+end_src
** TODO search packages and functions in this org file
* End
#+begin_src emacs-lisp
(add-hook 'window-setup-hook
          #'(lambda ()
              (+my/open-org-agenda)
              (message "Start in %s s" (float-time (time-subtract (current-time) +my/start-time)))))

(provide 'init)
#+end_src


;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
;; End:
